/*
 * Copyright (C) 2017-2018 GIG Technology NV and Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"log"

	datastor "github.com/threefoldtech/0-stor/client/datastor/zerodb"
	"github.com/threefoldtech/0-stor/client/processing"
)

// This example shows how you can process data prior to storage,
// while still keeping it simple and without any need for metadata.
//
// Should you not require any processing you can check the `hello_zstordb`,
// for an example on how to just set and get data, using a zstordb server.

// MiniClient is a custom client which we use to write and read data.
// Prior to writing it will compress and encrypt the data,
// and it will decrypt and decompress it once again when reading the data.
// This is just an example client and skips a lot of stuff,
// such as error handling and functionality other than getting and setting data.
type MiniClient struct {
	zstor     *datastor.Client
	processor processing.Processor
}

// NewMiniClient creates a new *Mini* Client,
// see MiniClient for more information.
func NewMiniClient(address, namespace string, privKey []byte) (*MiniClient, error) {
	// TODO: error handling, custom processing, ...

	// create sub-processors
	ed, err := processing.NewAESEncrypterDecrypter(privKey[:])
	if err != nil {
		return nil, err
	}
	cd, err := processing.NewSnappyCompressorDecompressor(processing.CompressionModeDefault)
	if err != nil {
		return nil, err
	}

	// create our datastor client
	zstor, err := datastor.NewClient(address, "", namespace)
	if err != nil {
		return nil, err
	}

	// create and return our mini client
	return &MiniClient{
		zstor:     zstor,
		processor: processing.NewProcessorChain([]processing.Processor{cd, ed}),
	}, nil
}

// SetData sets the given data, in compressed and encrypted form.
// When successfull it will return the key,
// that can be used to retrieve the data once again.
func (c *MiniClient) SetData(data []byte) (key []byte, err error) {
	data, err = c.processor.WriteProcess(data)
	if err != nil {
		return nil, err
	}
	return c.zstor.CreateObject(data)
}

// GetData returns the data for the given key.
// This key was generated by the zstordb server and returned
// by the (*MiniClient).SetData function, when storing the data.
// The data will be decrypted and decompressed prior to returning.
func (c *MiniClient) GetData(key []byte) (data []byte, err error) {
	object, err := c.zstor.GetObject(key)
	if err != nil {
		return nil, err
	}
	return c.processor.ReadProcess(object.Data)
}

func main() {
	// create our mini client
	client, err := NewMiniClient(
		"localhost:12345", "test",
		[]byte("12345678901234567890123456789012"))
	if err != nil {
		log.Fatal(err)
	}

	data := []byte("hello 0-stor")

	// write data
	key, err := client.SetData(data)
	if err != nil {
		log.Fatal(err)
	}

	// read data
	data, err = client.GetData(key)
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("stored data=%v\n", string(data))
}
