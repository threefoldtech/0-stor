/*
 * Copyright (C) 2017-2018 GIG Technology NV and Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//Package bencher provides the benchmarking logic
package bencher

import (
	"bytes"
	"fmt"
	"math"
	"math/rand"
	"time"

	log "github.com/sirupsen/logrus"
	"github.com/zero-os/0-stor/benchmark/config"
	"github.com/zero-os/0-stor/client"
	"github.com/zero-os/0-stor/client/metastor"
)

func init() {
	// seed random generator
	rand.Seed(time.Now().UnixNano())
}

const (
	// defaultKeyCount is used when BenchConf.Operations was not provided/invalid
	// when setting up the keys for the benchmark
	defaultKeyCount = 1000
)

var (
	// ResultOptions represent name mapping for benchmarking output options
	_ResultOptions = map[string]time.Duration{
		"per_second": time.Second,
		"per_minute": time.Minute,
		"per_hour":   time.Hour,
	}
)

// Result represents a benchmark result
type Result struct {
	// Total counted operations
	Count int64

	// Time elapsed of the benchmark
	Duration Duration

	// Amount of operations counted per predefined interval
	// (config.BenchmarkConfig.Output)
	PerInterval []int64
}

// Duration represents a duration of a test result
// used for custom YAML output
type Duration struct{ time.Duration }

// MarshalYAML implements yaml.Marshaler.MarshalYAML
func (d Duration) MarshalYAML() (interface{}, error) {
	return d.Seconds(), nil
}

// bencherFunc represents a benchmarking function
type bencherFunc func(client *client.Client, metaCli *metastor.Client, key, value []byte) error

// readFunc is a read benchmarking function
func readFunc(client *client.Client, metaCli *metastor.Client, k, v []byte) error {
	buf := bytes.NewBuffer(nil)
	md, err := metaCli.GetMetadata(k)
	if err != nil {
		return err
	}
	return client.Read(*md, buf)
}

// writeFunc is a write benchmarking function
func writeFunc(client *client.Client, metaCli *metastor.Client, k, v []byte) error {
	_, err := client.Write(k, bytes.NewReader(v))
	return err
}

// Bencher represents a benchmarker
type Bencher struct {
	client      *client.Client
	metaCli     *metastor.Client
	scenario    *config.Scenario
	scenarioID  string
	keys        [][]byte
	value       []byte
	bencherFunc bencherFunc
}

// NewBencher returns a new Bencher, which benchmarks the client's Read/Write functionality.
// Amount of keys are generated by number of `Operations` set in the benchconfig
// if `Operations` was 0 or less, the amount of keys will be `defaultKeyCount`
func NewBencher(scenarioID string, scenario *config.Scenario) (*Bencher, error) {
	bencher := new(Bencher)

	// set bencher fields
	bencher.scenarioID = scenarioID
	bencher.scenario = scenario

	// set bencher func
	switch scenario.BenchConf.Method {
	case config.BencherRead:
		bencher.bencherFunc = readFunc
	case config.BencherWrite:
		bencher.bencherFunc = writeFunc
	default:
		return nil, fmt.Errorf(
			"%d is an invalid/unsupported bencher method",
			scenario.BenchConf.Method)
	}

	var keys int
	if scenario.BenchConf.Operations <= 0 {
		keys = defaultKeyCount
	} else {
		keys = scenario.BenchConf.Operations
	}

	// generate data
	for i := 0; i < keys; i++ {
		bencher.keys = append(bencher.keys, generateData(scenario.BenchConf.KeySize))
	}
	bencher.value = generateData(scenario.BenchConf.ValueSize)

	// initializing client
	config.SetupClientConfig(&scenario.ZstorConf)
	var err error
	bencher.client, bencher.metaCli, err = newClientFromConfig(&scenario.ZstorConf, 1)
	if err != nil {
		return nil, fmt.Errorf("Failed creating client: %v", err)
	}

	if scenario.BenchConf.Method == config.BencherRead {
		// set testdata to client
		for _, key := range bencher.keys {
			_, err := bencher.client.Write(key, bytes.NewReader(bencher.value))
			if err != nil {
				return nil, fmt.Errorf(
					"Failed to write test data for read benchmarker: %v", err)
			}
		}
	}

	return bencher, nil
}

// RunBenchmark runs the read benchmarker
func (bencher *Bencher) RunBenchmark() (*Result, error) {
	var timeout <-chan time.Time
	if bencher.scenario.BenchConf.Duration > 0 {
		timeout = time.After(time.Duration(bencher.scenario.BenchConf.Duration) * time.Second)
	}

	// set up data aggregation interval
	interval := _ResultOptions[bencher.scenario.BenchConf.Output]

	var (
		tick            = time.Tick(interval)
		start           time.Time
		counter         int64
		intervalCounter int64
		result          = &Result{}
		keysLen         = len(bencher.keys)
		maxIterations   = bencher.scenario.BenchConf.Operations
	)

	if maxIterations == 0 {
		maxIterations = math.MaxInt64
	}

	start = time.Now()

BenchLoop:
	for i := 0; i < maxIterations; {
		// loop over the available keys
		key := bencher.keys[i%keysLen]

		select {
		case <-timeout:
			log.Debug("stopped on timeout")
			break BenchLoop
		case <-tick:
			result.PerInterval = append(result.PerInterval, intervalCounter)
			intervalCounter = 0
		default:
			err := bencher.bencherFunc(bencher.client, bencher.metaCli, key, bencher.value)
			if err != nil {
				return nil, err
			}
			intervalCounter++
			counter++
			i++
		}
	}

	result.Duration = Duration{time.Since(start)}
	result.Count = counter
	if tick != nil {
		result.PerInterval = append(result.PerInterval, intervalCounter)
	}

	return result, nil
}

// generateData generates a byteslice of provided length
// filled with random data
func generateData(len int) []byte {
	data := make([]byte, len)
	rand.Read(data)
	return data
}
