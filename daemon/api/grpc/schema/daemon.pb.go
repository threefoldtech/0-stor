// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema/daemon.proto

/*
	Package schema is a generated protocol buffer package.

	It is generated from these files:
		schema/daemon.proto

	It has these top-level messages:
		Metadata
		Chunk
		Object
		WriteRequest
		WriteResponse
		WriteFileRequest
		WriteFileResponse
		WriteStreamRequest
		WriteStreamResponse
		ReadRequest
		ReadResponse
		ReadFileRequest
		ReadFileResponse
		ReadStreamRequest
		ReadStreamResponse
		DeleteRequest
		DeleteResponse
		CheckRequest
		CheckResponse
		RepairRequest
		RepairResponse
		SetMetadataRequest
		SetMetadataResponse
		GetMetadataRequest
		GetMetadataResponse
		DeleteMetadataRequest
		DeleteMetadataResponse
		ListMetadataKeysRequest
		ListMetadataKeysResponse
		DataWriteRequest
		DataWriteResponse
		DataWriteFileRequest
		DataWriteFileResponse
		DataWriteStreamRequest
		DataWriteStreamResponse
		DataReadRequest
		DataReadResponse
		DataReadFileRequest
		DataReadFileResponse
		DataReadStreamRequest
		DataReadStreamResponse
		DataDeleteRequest
		DataDeleteResponse
		DataCheckRequest
		DataCheckResponse
		DataRepairRequest
		DataRepairResponse
*/
package schema

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type CheckStatus int32

const (
	CheckStatusInvalid CheckStatus = 0
	CheckStatusValid   CheckStatus = 1
	CheckStatusOptimal CheckStatus = 2
)

var CheckStatus_name = map[int32]string{
	0: "CheckStatusInvalid",
	1: "CheckStatusValid",
	2: "CheckStatusOptimal",
}
var CheckStatus_value = map[string]int32{
	"CheckStatusInvalid": 0,
	"CheckStatusValid":   1,
	"CheckStatusOptimal": 2,
}

func (CheckStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{0} }

type FileMode int32

const (
	// if the file already exists, truncate it to 0 bytes prior to writing
	FileModeTruncate FileMode = 0
	// append to the file should it already exists, otherwise create it
	FileModeAppend FileMode = 1
	// create a non-existing file and write to it
	FileModeExclusive FileMode = 2
)

var FileMode_name = map[int32]string{
	0: "FileModeTruncate",
	1: "FileModeAppend",
	2: "FileModeExclusive",
}
var FileMode_value = map[string]int32{
	"FileModeTruncate":  0,
	"FileModeAppend":    1,
	"FileModeExclusive": 2,
}

func (FileMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{1} }

type Metadata struct {
	// key defines the key of the data,
	// and is chosen by the owner of this data.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// totalSize in bytes represents the total size of all chunks,
	// that make up the stored data, combined.
	TotalSize int64 `protobuf:"varint,2,opt,name=totalSize,proto3" json:"totalSize,omitempty"`
	// creationEpoch defines the time this data was initially created,
	// in the Unix epoch format, in nano seconds.
	CreationEpoch int64 `protobuf:"varint,3,opt,name=creationEpoch,proto3" json:"creationEpoch,omitempty"`
	// lastWriteEpoch defines the time this data
	// was last modified (e.g. repaired),
	// in the Unix epoch format, in nano seconds.
	LastWriteEpoch int64 `protobuf:"varint,4,opt,name=lastWriteEpoch,proto3" json:"lastWriteEpoch,omitempty"`
	// chunks is the metadata list of all chunks
	// that make up the data, when combined.
	Chunks []*Chunk `protobuf:"bytes,5,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{0} }

func (m *Metadata) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Metadata) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Metadata) GetCreationEpoch() int64 {
	if m != nil {
		return m.CreationEpoch
	}
	return 0
}

func (m *Metadata) GetLastWriteEpoch() int64 {
	if m != nil {
		return m.LastWriteEpoch
	}
	return 0
}

func (m *Metadata) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type Chunk struct {
	// chunkSize of the chunk in bytes
	ChunkSize int64 `protobuf:"varint,1,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
	// objects defines the metadata of the objects
	// that make up this chunk.
	Objects []*Object `protobuf:"bytes,2,rep,name=objects" json:"objects,omitempty"`
	// hash contains the checksum/signature of the chunk (data),
	// meaning the data of all objects (of this chunk) combined.
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{1} }

func (m *Chunk) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *Chunk) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *Chunk) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Object struct {
	// key of the Object
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// shardID defines the ID of the shard the object is stored on
	ShardID string `protobuf:"bytes,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{2} }

func (m *Object) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Object) GetShardID() string {
	if m != nil {
		return m.ShardID
	}
	return ""
}

type WriteRequest struct {
	Key  []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{3} }

func (m *WriteRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WriteResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{4} }

func (m *WriteResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type WriteFileRequest struct {
	Key      []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	FilePath string `protobuf:"bytes,2,opt,name=filePath,proto3" json:"filePath,omitempty"`
}

func (m *WriteFileRequest) Reset()                    { *m = WriteFileRequest{} }
func (*WriteFileRequest) ProtoMessage()               {}
func (*WriteFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{5} }

func (m *WriteFileRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

type WriteFileResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *WriteFileResponse) Reset()                    { *m = WriteFileResponse{} }
func (*WriteFileResponse) ProtoMessage()               {}
func (*WriteFileResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{6} }

func (m *WriteFileResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// key is send as part of header
type WriteStreamRequest struct {
	// Types that are valid to be assigned to Input:
	//	*WriteStreamRequest_Metadata_
	//	*WriteStreamRequest_Data_
	Input isWriteStreamRequest_Input `protobuf_oneof:"input"`
}

func (m *WriteStreamRequest) Reset()                    { *m = WriteStreamRequest{} }
func (*WriteStreamRequest) ProtoMessage()               {}
func (*WriteStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{7} }

type isWriteStreamRequest_Input interface {
	isWriteStreamRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WriteStreamRequest_Metadata_ struct {
	Metadata *WriteStreamRequest_Metadata `protobuf:"bytes,1,opt,name=metadata,oneof"`
}
type WriteStreamRequest_Data_ struct {
	Data *WriteStreamRequest_Data `protobuf:"bytes,2,opt,name=data,oneof"`
}

func (*WriteStreamRequest_Metadata_) isWriteStreamRequest_Input() {}
func (*WriteStreamRequest_Data_) isWriteStreamRequest_Input()     {}

func (m *WriteStreamRequest) GetInput() isWriteStreamRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *WriteStreamRequest) GetMetadata() *WriteStreamRequest_Metadata {
	if x, ok := m.GetInput().(*WriteStreamRequest_Metadata_); ok {
		return x.Metadata
	}
	return nil
}

func (m *WriteStreamRequest) GetData() *WriteStreamRequest_Data {
	if x, ok := m.GetInput().(*WriteStreamRequest_Data_); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WriteStreamRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WriteStreamRequest_OneofMarshaler, _WriteStreamRequest_OneofUnmarshaler, _WriteStreamRequest_OneofSizer, []interface{}{
		(*WriteStreamRequest_Metadata_)(nil),
		(*WriteStreamRequest_Data_)(nil),
	}
}

func _WriteStreamRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WriteStreamRequest)
	// input
	switch x := m.Input.(type) {
	case *WriteStreamRequest_Metadata_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case *WriteStreamRequest_Data_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WriteStreamRequest.Input has unexpected type %T", x)
	}
	return nil
}

func _WriteStreamRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WriteStreamRequest)
	switch tag {
	case 1: // input.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WriteStreamRequest_Metadata)
		err := b.DecodeMessage(msg)
		m.Input = &WriteStreamRequest_Metadata_{msg}
		return true, err
	case 2: // input.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WriteStreamRequest_Data)
		err := b.DecodeMessage(msg)
		m.Input = &WriteStreamRequest_Data_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WriteStreamRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WriteStreamRequest)
	// input
	switch x := m.Input.(type) {
	case *WriteStreamRequest_Metadata_:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WriteStreamRequest_Data_:
		s := proto.Size(x.Data)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WriteStreamRequest_Metadata struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *WriteStreamRequest_Metadata) Reset()      { *m = WriteStreamRequest_Metadata{} }
func (*WriteStreamRequest_Metadata) ProtoMessage() {}
func (*WriteStreamRequest_Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptorDaemon, []int{7, 0}
}

func (m *WriteStreamRequest_Metadata) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type WriteStreamRequest_Data struct {
	DataChunk []byte `protobuf:"bytes,2,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *WriteStreamRequest_Data) Reset()                    { *m = WriteStreamRequest_Data{} }
func (*WriteStreamRequest_Data) ProtoMessage()               {}
func (*WriteStreamRequest_Data) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{7, 1} }

func (m *WriteStreamRequest_Data) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type WriteStreamResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *WriteStreamResponse) Reset()                    { *m = WriteStreamResponse{} }
func (*WriteStreamResponse) ProtoMessage()               {}
func (*WriteStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{8} }

func (m *WriteStreamResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ReadRequest struct {
	// Types that are valid to be assigned to Input:
	//	*ReadRequest_Key
	//	*ReadRequest_Metadata
	Input isReadRequest_Input `protobuf_oneof:"input"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{9} }

type isReadRequest_Input interface {
	isReadRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}
type ReadRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,oneof"`
}

func (*ReadRequest_Key) isReadRequest_Input()      {}
func (*ReadRequest_Metadata) isReadRequest_Input() {}

func (m *ReadRequest) GetInput() isReadRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ReadRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*ReadRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *ReadRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*ReadRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReadRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReadRequest_OneofMarshaler, _ReadRequest_OneofUnmarshaler, _ReadRequest_OneofSizer, []interface{}{
		(*ReadRequest_Key)(nil),
		(*ReadRequest_Metadata)(nil),
	}
}

func _ReadRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReadRequest)
	// input
	switch x := m.Input.(type) {
	case *ReadRequest_Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Key)
	case *ReadRequest_Metadata:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReadRequest.Input has unexpected type %T", x)
	}
	return nil
}

func _ReadRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReadRequest)
	switch tag {
	case 1: // input.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Input = &ReadRequest_Key{x}
		return true, err
	case 2: // input.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Input = &ReadRequest_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReadRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReadRequest)
	// input
	switch x := m.Input.(type) {
	case *ReadRequest_Key:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Key)))
		n += len(x.Key)
	case *ReadRequest_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReadResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{10} }

func (m *ReadResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ReadFileRequest struct {
	// Types that are valid to be assigned to Input:
	//	*ReadFileRequest_Key
	//	*ReadFileRequest_Metadata
	Input isReadFileRequest_Input `protobuf_oneof:"input"`
	// destination file and its configuration
	FilePath      string   `protobuf:"bytes,3,opt,name=filePath,proto3" json:"filePath,omitempty"`
	FileMode      FileMode `protobuf:"varint,4,opt,name=fileMode,proto3,enum=schema.FileMode" json:"fileMode,omitempty"`
	SynchronousIO bool     `protobuf:"varint,5,opt,name=synchronousIO,proto3" json:"synchronousIO,omitempty"`
}

func (m *ReadFileRequest) Reset()                    { *m = ReadFileRequest{} }
func (*ReadFileRequest) ProtoMessage()               {}
func (*ReadFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{11} }

type isReadFileRequest_Input interface {
	isReadFileRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadFileRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}
type ReadFileRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,oneof"`
}

func (*ReadFileRequest_Key) isReadFileRequest_Input()      {}
func (*ReadFileRequest_Metadata) isReadFileRequest_Input() {}

func (m *ReadFileRequest) GetInput() isReadFileRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ReadFileRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*ReadFileRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *ReadFileRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*ReadFileRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *ReadFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *ReadFileRequest) GetFileMode() FileMode {
	if m != nil {
		return m.FileMode
	}
	return FileModeTruncate
}

func (m *ReadFileRequest) GetSynchronousIO() bool {
	if m != nil {
		return m.SynchronousIO
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReadFileRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReadFileRequest_OneofMarshaler, _ReadFileRequest_OneofUnmarshaler, _ReadFileRequest_OneofSizer, []interface{}{
		(*ReadFileRequest_Key)(nil),
		(*ReadFileRequest_Metadata)(nil),
	}
}

func _ReadFileRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReadFileRequest)
	// input
	switch x := m.Input.(type) {
	case *ReadFileRequest_Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Key)
	case *ReadFileRequest_Metadata:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReadFileRequest.Input has unexpected type %T", x)
	}
	return nil
}

func _ReadFileRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReadFileRequest)
	switch tag {
	case 1: // input.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Input = &ReadFileRequest_Key{x}
		return true, err
	case 2: // input.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Input = &ReadFileRequest_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReadFileRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReadFileRequest)
	// input
	switch x := m.Input.(type) {
	case *ReadFileRequest_Key:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Key)))
		n += len(x.Key)
	case *ReadFileRequest_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReadFileResponse struct {
}

func (m *ReadFileResponse) Reset()                    { *m = ReadFileResponse{} }
func (*ReadFileResponse) ProtoMessage()               {}
func (*ReadFileResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{12} }

type ReadStreamRequest struct {
	// Types that are valid to be assigned to Input:
	//	*ReadStreamRequest_Key
	//	*ReadStreamRequest_Metadata
	Input     isReadStreamRequest_Input `protobuf_oneof:"input"`
	ChunkSize int64                     `protobuf:"varint,3,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
}

func (m *ReadStreamRequest) Reset()                    { *m = ReadStreamRequest{} }
func (*ReadStreamRequest) ProtoMessage()               {}
func (*ReadStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{13} }

type isReadStreamRequest_Input interface {
	isReadStreamRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadStreamRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}
type ReadStreamRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,oneof"`
}

func (*ReadStreamRequest_Key) isReadStreamRequest_Input()      {}
func (*ReadStreamRequest_Metadata) isReadStreamRequest_Input() {}

func (m *ReadStreamRequest) GetInput() isReadStreamRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ReadStreamRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*ReadStreamRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *ReadStreamRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*ReadStreamRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *ReadStreamRequest) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReadStreamRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReadStreamRequest_OneofMarshaler, _ReadStreamRequest_OneofUnmarshaler, _ReadStreamRequest_OneofSizer, []interface{}{
		(*ReadStreamRequest_Key)(nil),
		(*ReadStreamRequest_Metadata)(nil),
	}
}

func _ReadStreamRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReadStreamRequest)
	// input
	switch x := m.Input.(type) {
	case *ReadStreamRequest_Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Key)
	case *ReadStreamRequest_Metadata:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReadStreamRequest.Input has unexpected type %T", x)
	}
	return nil
}

func _ReadStreamRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReadStreamRequest)
	switch tag {
	case 1: // input.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Input = &ReadStreamRequest_Key{x}
		return true, err
	case 2: // input.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Input = &ReadStreamRequest_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReadStreamRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReadStreamRequest)
	// input
	switch x := m.Input.(type) {
	case *ReadStreamRequest_Key:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Key)))
		n += len(x.Key)
	case *ReadStreamRequest_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReadStreamResponse struct {
	DataChunk []byte `protobuf:"bytes,1,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *ReadStreamResponse) Reset()                    { *m = ReadStreamResponse{} }
func (*ReadStreamResponse) ProtoMessage()               {}
func (*ReadStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{14} }

func (m *ReadStreamResponse) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DeleteRequest struct {
	// Types that are valid to be assigned to Input:
	//	*DeleteRequest_Key
	//	*DeleteRequest_Metadata
	Input isDeleteRequest_Input `protobuf_oneof:"input"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{15} }

type isDeleteRequest_Input interface {
	isDeleteRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeleteRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}
type DeleteRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,oneof"`
}

func (*DeleteRequest_Key) isDeleteRequest_Input()      {}
func (*DeleteRequest_Metadata) isDeleteRequest_Input() {}

func (m *DeleteRequest) GetInput() isDeleteRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *DeleteRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*DeleteRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *DeleteRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*DeleteRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeleteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeleteRequest_OneofMarshaler, _DeleteRequest_OneofUnmarshaler, _DeleteRequest_OneofSizer, []interface{}{
		(*DeleteRequest_Key)(nil),
		(*DeleteRequest_Metadata)(nil),
	}
}

func _DeleteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeleteRequest)
	// input
	switch x := m.Input.(type) {
	case *DeleteRequest_Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Key)
	case *DeleteRequest_Metadata:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeleteRequest.Input has unexpected type %T", x)
	}
	return nil
}

func _DeleteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeleteRequest)
	switch tag {
	case 1: // input.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Input = &DeleteRequest_Key{x}
		return true, err
	case 2: // input.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Input = &DeleteRequest_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeleteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeleteRequest)
	// input
	switch x := m.Input.(type) {
	case *DeleteRequest_Key:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Key)))
		n += len(x.Key)
	case *DeleteRequest_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DeleteResponse struct {
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{16} }

type CheckRequest struct {
	// Types that are valid to be assigned to Input:
	//	*CheckRequest_Key
	//	*CheckRequest_Metadata
	Input isCheckRequest_Input `protobuf_oneof:"input"`
	Fast  bool                 `protobuf:"varint,3,opt,name=fast,proto3" json:"fast,omitempty"`
}

func (m *CheckRequest) Reset()                    { *m = CheckRequest{} }
func (*CheckRequest) ProtoMessage()               {}
func (*CheckRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{17} }

type isCheckRequest_Input interface {
	isCheckRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CheckRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}
type CheckRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,oneof"`
}

func (*CheckRequest_Key) isCheckRequest_Input()      {}
func (*CheckRequest_Metadata) isCheckRequest_Input() {}

func (m *CheckRequest) GetInput() isCheckRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CheckRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*CheckRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *CheckRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*CheckRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *CheckRequest) GetFast() bool {
	if m != nil {
		return m.Fast
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CheckRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CheckRequest_OneofMarshaler, _CheckRequest_OneofUnmarshaler, _CheckRequest_OneofSizer, []interface{}{
		(*CheckRequest_Key)(nil),
		(*CheckRequest_Metadata)(nil),
	}
}

func _CheckRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CheckRequest)
	// input
	switch x := m.Input.(type) {
	case *CheckRequest_Key:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Key)
	case *CheckRequest_Metadata:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CheckRequest.Input has unexpected type %T", x)
	}
	return nil
}

func _CheckRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CheckRequest)
	switch tag {
	case 1: // input.key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Input = &CheckRequest_Key{x}
		return true, err
	case 2: // input.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Metadata)
		err := b.DecodeMessage(msg)
		m.Input = &CheckRequest_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CheckRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CheckRequest)
	// input
	switch x := m.Input.(type) {
	case *CheckRequest_Key:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Key)))
		n += len(x.Key)
	case *CheckRequest_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CheckResponse struct {
	Status CheckStatus `protobuf:"varint,1,opt,name=status,proto3,enum=schema.CheckStatus" json:"status,omitempty"`
}

func (m *CheckResponse) Reset()                    { *m = CheckResponse{} }
func (*CheckResponse) ProtoMessage()               {}
func (*CheckResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{18} }

func (m *CheckResponse) GetStatus() CheckStatus {
	if m != nil {
		return m.Status
	}
	return CheckStatusInvalid
}

type RepairRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *RepairRequest) Reset()                    { *m = RepairRequest{} }
func (*RepairRequest) ProtoMessage()               {}
func (*RepairRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{19} }

func (m *RepairRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type RepairResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *RepairResponse) Reset()                    { *m = RepairResponse{} }
func (*RepairResponse) ProtoMessage()               {}
func (*RepairResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{20} }

func (m *RepairResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type SetMetadataRequest struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *SetMetadataRequest) Reset()                    { *m = SetMetadataRequest{} }
func (*SetMetadataRequest) ProtoMessage()               {}
func (*SetMetadataRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{21} }

func (m *SetMetadataRequest) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type SetMetadataResponse struct {
}

func (m *SetMetadataResponse) Reset()                    { *m = SetMetadataResponse{} }
func (*SetMetadataResponse) ProtoMessage()               {}
func (*SetMetadataResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{22} }

type GetMetadataRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetMetadataRequest) Reset()                    { *m = GetMetadataRequest{} }
func (*GetMetadataRequest) ProtoMessage()               {}
func (*GetMetadataRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{23} }

func (m *GetMetadataRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type GetMetadataResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *GetMetadataResponse) Reset()                    { *m = GetMetadataResponse{} }
func (*GetMetadataResponse) ProtoMessage()               {}
func (*GetMetadataResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{24} }

func (m *GetMetadataResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type DeleteMetadataRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DeleteMetadataRequest) Reset()                    { *m = DeleteMetadataRequest{} }
func (*DeleteMetadataRequest) ProtoMessage()               {}
func (*DeleteMetadataRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{25} }

func (m *DeleteMetadataRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DeleteMetadataResponse struct {
}

func (m *DeleteMetadataResponse) Reset()                    { *m = DeleteMetadataResponse{} }
func (*DeleteMetadataResponse) ProtoMessage()               {}
func (*DeleteMetadataResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{26} }

type ListMetadataKeysRequest struct {
}

func (m *ListMetadataKeysRequest) Reset()                    { *m = ListMetadataKeysRequest{} }
func (*ListMetadataKeysRequest) ProtoMessage()               {}
func (*ListMetadataKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{27} }

type ListMetadataKeysResponse struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ListMetadataKeysResponse) Reset()                    { *m = ListMetadataKeysResponse{} }
func (*ListMetadataKeysResponse) ProtoMessage()               {}
func (*ListMetadataKeysResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{28} }

func (m *ListMetadataKeysResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DataWriteRequest struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataWriteRequest) Reset()                    { *m = DataWriteRequest{} }
func (*DataWriteRequest) ProtoMessage()               {}
func (*DataWriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{29} }

func (m *DataWriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DataWriteResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataWriteResponse) Reset()                    { *m = DataWriteResponse{} }
func (*DataWriteResponse) ProtoMessage()               {}
func (*DataWriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{30} }

func (m *DataWriteResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataWriteFileRequest struct {
	FilePath string `protobuf:"bytes,1,opt,name=filePath,proto3" json:"filePath,omitempty"`
}

func (m *DataWriteFileRequest) Reset()                    { *m = DataWriteFileRequest{} }
func (*DataWriteFileRequest) ProtoMessage()               {}
func (*DataWriteFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{31} }

func (m *DataWriteFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

type DataWriteFileResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataWriteFileResponse) Reset()                    { *m = DataWriteFileResponse{} }
func (*DataWriteFileResponse) ProtoMessage()               {}
func (*DataWriteFileResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{32} }

func (m *DataWriteFileResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataWriteStreamRequest struct {
	DataChunk []byte `protobuf:"bytes,1,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *DataWriteStreamRequest) Reset()                    { *m = DataWriteStreamRequest{} }
func (*DataWriteStreamRequest) ProtoMessage()               {}
func (*DataWriteStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{33} }

func (m *DataWriteStreamRequest) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DataWriteStreamResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataWriteStreamResponse) Reset()                    { *m = DataWriteStreamResponse{} }
func (*DataWriteStreamResponse) ProtoMessage()               {}
func (*DataWriteStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{34} }

func (m *DataWriteStreamResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataReadRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataReadRequest) Reset()                    { *m = DataReadRequest{} }
func (*DataReadRequest) ProtoMessage()               {}
func (*DataReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{35} }

func (m *DataReadRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataReadResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataReadResponse) Reset()                    { *m = DataReadResponse{} }
func (*DataReadResponse) ProtoMessage()               {}
func (*DataReadResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{36} }

func (m *DataReadResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DataReadFileRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
	// destination file and its configuration
	FilePath      string   `protobuf:"bytes,2,opt,name=filePath,proto3" json:"filePath,omitempty"`
	FileMode      FileMode `protobuf:"varint,3,opt,name=fileMode,proto3,enum=schema.FileMode" json:"fileMode,omitempty"`
	SynchronousIO bool     `protobuf:"varint,4,opt,name=synchronousIO,proto3" json:"synchronousIO,omitempty"`
}

func (m *DataReadFileRequest) Reset()                    { *m = DataReadFileRequest{} }
func (*DataReadFileRequest) ProtoMessage()               {}
func (*DataReadFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{37} }

func (m *DataReadFileRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *DataReadFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *DataReadFileRequest) GetFileMode() FileMode {
	if m != nil {
		return m.FileMode
	}
	return FileModeTruncate
}

func (m *DataReadFileRequest) GetSynchronousIO() bool {
	if m != nil {
		return m.SynchronousIO
	}
	return false
}

type DataReadFileResponse struct {
}

func (m *DataReadFileResponse) Reset()                    { *m = DataReadFileResponse{} }
func (*DataReadFileResponse) ProtoMessage()               {}
func (*DataReadFileResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{38} }

type DataReadStreamRequest struct {
	Chunks    []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
	ChunkSize int64    `protobuf:"varint,2,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
}

func (m *DataReadStreamRequest) Reset()                    { *m = DataReadStreamRequest{} }
func (*DataReadStreamRequest) ProtoMessage()               {}
func (*DataReadStreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{39} }

func (m *DataReadStreamRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *DataReadStreamRequest) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

type DataReadStreamResponse struct {
	DataChunk []byte `protobuf:"bytes,1,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *DataReadStreamResponse) Reset()                    { *m = DataReadStreamResponse{} }
func (*DataReadStreamResponse) ProtoMessage()               {}
func (*DataReadStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{40} }

func (m *DataReadStreamResponse) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DataDeleteRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataDeleteRequest) Reset()                    { *m = DataDeleteRequest{} }
func (*DataDeleteRequest) ProtoMessage()               {}
func (*DataDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{41} }

func (m *DataDeleteRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataDeleteResponse struct {
}

func (m *DataDeleteResponse) Reset()                    { *m = DataDeleteResponse{} }
func (*DataDeleteResponse) ProtoMessage()               {}
func (*DataDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{42} }

type DataCheckRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
	Fast   bool     `protobuf:"varint,2,opt,name=fast,proto3" json:"fast,omitempty"`
}

func (m *DataCheckRequest) Reset()                    { *m = DataCheckRequest{} }
func (*DataCheckRequest) ProtoMessage()               {}
func (*DataCheckRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{43} }

func (m *DataCheckRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *DataCheckRequest) GetFast() bool {
	if m != nil {
		return m.Fast
	}
	return false
}

type DataCheckResponse struct {
	Status CheckStatus `protobuf:"varint,1,opt,name=status,proto3,enum=schema.CheckStatus" json:"status,omitempty"`
}

func (m *DataCheckResponse) Reset()                    { *m = DataCheckResponse{} }
func (*DataCheckResponse) ProtoMessage()               {}
func (*DataCheckResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{44} }

func (m *DataCheckResponse) GetStatus() CheckStatus {
	if m != nil {
		return m.Status
	}
	return CheckStatusInvalid
}

type DataRepairRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataRepairRequest) Reset()                    { *m = DataRepairRequest{} }
func (*DataRepairRequest) ProtoMessage()               {}
func (*DataRepairRequest) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{45} }

func (m *DataRepairRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataRepairResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
}

func (m *DataRepairResponse) Reset()                    { *m = DataRepairResponse{} }
func (*DataRepairResponse) ProtoMessage()               {}
func (*DataRepairResponse) Descriptor() ([]byte, []int) { return fileDescriptorDaemon, []int{46} }

func (m *DataRepairResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func init() {
	proto.RegisterType((*Metadata)(nil), "schema.Metadata")
	proto.RegisterType((*Chunk)(nil), "schema.Chunk")
	proto.RegisterType((*Object)(nil), "schema.Object")
	proto.RegisterType((*WriteRequest)(nil), "schema.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "schema.WriteResponse")
	proto.RegisterType((*WriteFileRequest)(nil), "schema.WriteFileRequest")
	proto.RegisterType((*WriteFileResponse)(nil), "schema.WriteFileResponse")
	proto.RegisterType((*WriteStreamRequest)(nil), "schema.WriteStreamRequest")
	proto.RegisterType((*WriteStreamRequest_Metadata)(nil), "schema.WriteStreamRequest.Metadata")
	proto.RegisterType((*WriteStreamRequest_Data)(nil), "schema.WriteStreamRequest.Data")
	proto.RegisterType((*WriteStreamResponse)(nil), "schema.WriteStreamResponse")
	proto.RegisterType((*ReadRequest)(nil), "schema.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "schema.ReadResponse")
	proto.RegisterType((*ReadFileRequest)(nil), "schema.ReadFileRequest")
	proto.RegisterType((*ReadFileResponse)(nil), "schema.ReadFileResponse")
	proto.RegisterType((*ReadStreamRequest)(nil), "schema.ReadStreamRequest")
	proto.RegisterType((*ReadStreamResponse)(nil), "schema.ReadStreamResponse")
	proto.RegisterType((*DeleteRequest)(nil), "schema.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "schema.DeleteResponse")
	proto.RegisterType((*CheckRequest)(nil), "schema.CheckRequest")
	proto.RegisterType((*CheckResponse)(nil), "schema.CheckResponse")
	proto.RegisterType((*RepairRequest)(nil), "schema.RepairRequest")
	proto.RegisterType((*RepairResponse)(nil), "schema.RepairResponse")
	proto.RegisterType((*SetMetadataRequest)(nil), "schema.SetMetadataRequest")
	proto.RegisterType((*SetMetadataResponse)(nil), "schema.SetMetadataResponse")
	proto.RegisterType((*GetMetadataRequest)(nil), "schema.GetMetadataRequest")
	proto.RegisterType((*GetMetadataResponse)(nil), "schema.GetMetadataResponse")
	proto.RegisterType((*DeleteMetadataRequest)(nil), "schema.DeleteMetadataRequest")
	proto.RegisterType((*DeleteMetadataResponse)(nil), "schema.DeleteMetadataResponse")
	proto.RegisterType((*ListMetadataKeysRequest)(nil), "schema.ListMetadataKeysRequest")
	proto.RegisterType((*ListMetadataKeysResponse)(nil), "schema.ListMetadataKeysResponse")
	proto.RegisterType((*DataWriteRequest)(nil), "schema.DataWriteRequest")
	proto.RegisterType((*DataWriteResponse)(nil), "schema.DataWriteResponse")
	proto.RegisterType((*DataWriteFileRequest)(nil), "schema.DataWriteFileRequest")
	proto.RegisterType((*DataWriteFileResponse)(nil), "schema.DataWriteFileResponse")
	proto.RegisterType((*DataWriteStreamRequest)(nil), "schema.DataWriteStreamRequest")
	proto.RegisterType((*DataWriteStreamResponse)(nil), "schema.DataWriteStreamResponse")
	proto.RegisterType((*DataReadRequest)(nil), "schema.DataReadRequest")
	proto.RegisterType((*DataReadResponse)(nil), "schema.DataReadResponse")
	proto.RegisterType((*DataReadFileRequest)(nil), "schema.DataReadFileRequest")
	proto.RegisterType((*DataReadFileResponse)(nil), "schema.DataReadFileResponse")
	proto.RegisterType((*DataReadStreamRequest)(nil), "schema.DataReadStreamRequest")
	proto.RegisterType((*DataReadStreamResponse)(nil), "schema.DataReadStreamResponse")
	proto.RegisterType((*DataDeleteRequest)(nil), "schema.DataDeleteRequest")
	proto.RegisterType((*DataDeleteResponse)(nil), "schema.DataDeleteResponse")
	proto.RegisterType((*DataCheckRequest)(nil), "schema.DataCheckRequest")
	proto.RegisterType((*DataCheckResponse)(nil), "schema.DataCheckResponse")
	proto.RegisterType((*DataRepairRequest)(nil), "schema.DataRepairRequest")
	proto.RegisterType((*DataRepairResponse)(nil), "schema.DataRepairResponse")
	proto.RegisterEnum("schema.CheckStatus", CheckStatus_name, CheckStatus_value)
	proto.RegisterEnum("schema.FileMode", FileMode_name, FileMode_value)
}
func (x CheckStatus) String() string {
	s, ok := CheckStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FileMode) String() string {
	s, ok := FileMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Metadata)
	if !ok {
		that2, ok := that.(Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.TotalSize != that1.TotalSize {
		return false
	}
	if this.CreationEpoch != that1.CreationEpoch {
		return false
	}
	if this.LastWriteEpoch != that1.LastWriteEpoch {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *Chunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Chunk)
	if !ok {
		that2, ok := that.(Chunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	if len(this.Objects) != len(that1.Objects) {
		return false
	}
	for i := range this.Objects {
		if !this.Objects[i].Equal(that1.Objects[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *Object) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Object)
	if !ok {
		that2, ok := that.(Object)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.ShardID != that1.ShardID {
		return false
	}
	return true
}
func (this *WriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteRequest)
	if !ok {
		that2, ok := that.(WriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *WriteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteResponse)
	if !ok {
		that2, ok := that.(WriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *WriteFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteFileRequest)
	if !ok {
		that2, ok := that.(WriteFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	return true
}
func (this *WriteFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteFileResponse)
	if !ok {
		that2, ok := that.(WriteFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *WriteStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest)
	if !ok {
		that2, ok := that.(WriteStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Metadata_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Metadata_)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Metadata_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Data_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Data_)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Data_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Metadata)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Data) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Data)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Data)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *WriteStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamResponse)
	if !ok {
		that2, ok := that.(WriteStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	return true
}
func (this *ReadRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest_Key)
	if !ok {
		that2, ok := that.(ReadRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest_Metadata)
	if !ok {
		that2, ok := that.(ReadRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadResponse)
	if !ok {
		that2, ok := that.(ReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *ReadFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest)
	if !ok {
		that2, ok := that.(ReadFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.SynchronousIO != that1.SynchronousIO {
		return false
	}
	return true
}
func (this *ReadFileRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest_Key)
	if !ok {
		that2, ok := that.(ReadFileRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadFileRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest_Metadata)
	if !ok {
		that2, ok := that.(ReadFileRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileResponse)
	if !ok {
		that2, ok := that.(ReadFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ReadStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest)
	if !ok {
		that2, ok := that.(ReadStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	return true
}
func (this *ReadStreamRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest_Key)
	if !ok {
		that2, ok := that.(ReadStreamRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadStreamRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest_Metadata)
	if !ok {
		that2, ok := that.(ReadStreamRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamResponse)
	if !ok {
		that2, ok := that.(ReadStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *DeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest)
	if !ok {
		that2, ok := that.(DeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	return true
}
func (this *DeleteRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest_Key)
	if !ok {
		that2, ok := that.(DeleteRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *DeleteRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest_Metadata)
	if !ok {
		that2, ok := that.(DeleteRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *DeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteResponse)
	if !ok {
		that2, ok := that.(DeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest)
	if !ok {
		that2, ok := that.(CheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	if this.Fast != that1.Fast {
		return false
	}
	return true
}
func (this *CheckRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest_Key)
	if !ok {
		that2, ok := that.(CheckRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *CheckRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest_Metadata)
	if !ok {
		that2, ok := that.(CheckRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *CheckResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckResponse)
	if !ok {
		that2, ok := that.(CheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *RepairRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepairRequest)
	if !ok {
		that2, ok := that.(RepairRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *RepairResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepairResponse)
	if !ok {
		that2, ok := that.(RepairResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *SetMetadataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetMetadataRequest)
	if !ok {
		that2, ok := that.(SetMetadataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *SetMetadataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetMetadataResponse)
	if !ok {
		that2, ok := that.(SetMetadataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetMetadataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetMetadataRequest)
	if !ok {
		that2, ok := that.(GetMetadataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *GetMetadataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetMetadataResponse)
	if !ok {
		that2, ok := that.(GetMetadataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *DeleteMetadataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteMetadataRequest)
	if !ok {
		that2, ok := that.(DeleteMetadataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *DeleteMetadataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteMetadataResponse)
	if !ok {
		that2, ok := that.(DeleteMetadataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ListMetadataKeysRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetadataKeysRequest)
	if !ok {
		that2, ok := that.(ListMetadataKeysRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ListMetadataKeysResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetadataKeysResponse)
	if !ok {
		that2, ok := that.(ListMetadataKeysResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *DataWriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteRequest)
	if !ok {
		that2, ok := that.(DataWriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *DataWriteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteResponse)
	if !ok {
		that2, ok := that.(DataWriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataWriteFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteFileRequest)
	if !ok {
		that2, ok := that.(DataWriteFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	return true
}
func (this *DataWriteFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteFileResponse)
	if !ok {
		that2, ok := that.(DataWriteFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataWriteStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteStreamRequest)
	if !ok {
		that2, ok := that.(DataWriteStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *DataWriteStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteStreamResponse)
	if !ok {
		that2, ok := that.(DataWriteStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadRequest)
	if !ok {
		that2, ok := that.(DataReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadResponse)
	if !ok {
		that2, ok := that.(DataReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *DataReadFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadFileRequest)
	if !ok {
		that2, ok := that.(DataReadFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.SynchronousIO != that1.SynchronousIO {
		return false
	}
	return true
}
func (this *DataReadFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadFileResponse)
	if !ok {
		that2, ok := that.(DataReadFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DataReadStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadStreamRequest)
	if !ok {
		that2, ok := that.(DataReadStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	return true
}
func (this *DataReadStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadStreamResponse)
	if !ok {
		that2, ok := that.(DataReadStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *DataDeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataDeleteRequest)
	if !ok {
		that2, ok := that.(DataDeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataDeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataDeleteResponse)
	if !ok {
		that2, ok := that.(DataDeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DataCheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataCheckRequest)
	if !ok {
		that2, ok := that.(DataCheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if this.Fast != that1.Fast {
		return false
	}
	return true
}
func (this *DataCheckResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataCheckResponse)
	if !ok {
		that2, ok := that.(DataCheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *DataRepairRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataRepairRequest)
	if !ok {
		that2, ok := that.(DataRepairRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataRepairResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataRepairResponse)
	if !ok {
		that2, ok := that.(DataRepairResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.Metadata{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "TotalSize: "+fmt.Sprintf("%#v", this.TotalSize)+",\n")
	s = append(s, "CreationEpoch: "+fmt.Sprintf("%#v", this.CreationEpoch)+",\n")
	s = append(s, "LastWriteEpoch: "+fmt.Sprintf("%#v", this.LastWriteEpoch)+",\n")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Chunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.Chunk{")
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	if this.Objects != nil {
		s = append(s, "Objects: "+fmt.Sprintf("%#v", this.Objects)+",\n")
	}
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Object) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Object{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "ShardID: "+fmt.Sprintf("%#v", this.ShardID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WriteRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WriteFileRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteFileResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WriteStreamRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest_Metadata_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WriteStreamRequest_Metadata_{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *WriteStreamRequest_Data_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WriteStreamRequest_Data_{` +
		`Data:` + fmt.Sprintf("%#v", this.Data) + `}`}, ", ")
	return s
}
func (this *WriteStreamRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteStreamRequest_Metadata{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest_Data) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteStreamRequest_Data{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteStreamResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ReadRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *ReadRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *ReadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ReadResponse{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.ReadFileRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "FileMode: "+fmt.Sprintf("%#v", this.FileMode)+",\n")
	s = append(s, "SynchronousIO: "+fmt.Sprintf("%#v", this.SynchronousIO)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadFileRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadFileRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *ReadFileRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadFileRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *ReadFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.ReadFileResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.ReadStreamRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadStreamRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadStreamRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *ReadStreamRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadStreamRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *ReadStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ReadStreamResponse{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DeleteRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DeleteRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *DeleteRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DeleteRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *DeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DeleteResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.CheckRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "Fast: "+fmt.Sprintf("%#v", this.Fast)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CheckRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *CheckRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CheckRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *CheckResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.CheckResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepairRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.RepairRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepairResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.RepairResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetMetadataRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.SetMetadataRequest{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetMetadataResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.SetMetadataResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetMetadataRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.GetMetadataRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetMetadataResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.GetMetadataResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMetadataRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DeleteMetadataRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMetadataResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DeleteMetadataResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetadataKeysRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.ListMetadataKeysRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetadataKeysResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ListMetadataKeysResponse{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteRequest{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteFileRequest{")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteFileResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteStreamRequest{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteStreamResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataReadRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataReadResponse{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.DataReadFileRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "FileMode: "+fmt.Sprintf("%#v", this.FileMode)+",\n")
	s = append(s, "SynchronousIO: "+fmt.Sprintf("%#v", this.SynchronousIO)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DataReadFileResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DataReadStreamRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataReadStreamResponse{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataDeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataDeleteRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataDeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DataDeleteResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataCheckRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DataCheckRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "Fast: "+fmt.Sprintf("%#v", this.Fast)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataCheckResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataCheckResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataRepairRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataRepairRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataRepairResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataRepairResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDaemon(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FileService service

type FileServiceClient interface {
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error)
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (FileService_WriteStreamClient, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error)
	ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (FileService_ReadStreamClient, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	Check(ctx context.Context, in *CheckRequest, opts ...grpc.CallOption) (*CheckResponse, error)
	Repair(ctx context.Context, in *RepairRequest, opts ...grpc.CallOption) (*RepairResponse, error)
}

type fileServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileServiceClient(cc *grpc.ClientConn) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error) {
	out := new(WriteFileResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/WriteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (FileService_WriteStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileService_serviceDesc.Streams[0], c.cc, "/schema.FileService/WriteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceWriteStreamClient{stream}
	return x, nil
}

type FileService_WriteStreamClient interface {
	Send(*WriteStreamRequest) error
	CloseAndRecv() (*WriteStreamResponse, error)
	grpc.ClientStream
}

type fileServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *fileServiceWriteStreamClient) Send(m *WriteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileServiceWriteStreamClient) CloseAndRecv() (*WriteStreamResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error) {
	out := new(ReadFileResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/ReadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (FileService_ReadStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileService_serviceDesc.Streams[1], c.cc, "/schema.FileService/ReadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileService_ReadStreamClient interface {
	Recv() (*ReadStreamResponse, error)
	grpc.ClientStream
}

type fileServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *fileServiceReadStreamClient) Recv() (*ReadStreamResponse, error) {
	m := new(ReadStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Check(ctx context.Context, in *CheckRequest, opts ...grpc.CallOption) (*CheckResponse, error) {
	out := new(CheckResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/Check", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Repair(ctx context.Context, in *RepairRequest, opts ...grpc.CallOption) (*RepairResponse, error) {
	out := new(RepairResponse)
	err := grpc.Invoke(ctx, "/schema.FileService/Repair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileService service

type FileServiceServer interface {
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	WriteFile(context.Context, *WriteFileRequest) (*WriteFileResponse, error)
	WriteStream(FileService_WriteStreamServer) error
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error)
	ReadStream(*ReadStreamRequest, FileService_ReadStreamServer) error
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	Check(context.Context, *CheckRequest) (*CheckResponse, error)
	Repair(context.Context, *RepairRequest) (*RepairResponse, error)
}

func RegisterFileServiceServer(s *grpc.Server, srv FileServiceServer) {
	s.RegisterService(&_FileService_serviceDesc, srv)
}

func _FileService_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/WriteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).WriteFile(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileServiceServer).WriteStream(&fileServiceWriteStreamServer{stream})
}

type FileService_WriteStreamServer interface {
	SendAndClose(*WriteStreamResponse) error
	Recv() (*WriteStreamRequest, error)
	grpc.ServerStream
}

type fileServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *fileServiceWriteStreamServer) SendAndClose(m *WriteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileServiceWriteStreamServer) Recv() (*WriteStreamRequest, error) {
	m := new(WriteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/ReadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ReadFile(ctx, req.(*ReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileServiceServer).ReadStream(m, &fileServiceReadStreamServer{stream})
}

type FileService_ReadStreamServer interface {
	Send(*ReadStreamResponse) error
	grpc.ServerStream
}

type fileServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *fileServiceReadStreamServer) Send(m *ReadStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _FileService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Check(ctx, req.(*CheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Repair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Repair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Repair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Repair(ctx, req.(*RepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schema.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _FileService_Write_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FileService_WriteFile_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _FileService_Read_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FileService_ReadFile_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FileService_Delete_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _FileService_Check_Handler,
		},
		{
			MethodName: "Repair",
			Handler:    _FileService_Repair_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteStream",
			Handler:       _FileService_WriteStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadStream",
			Handler:       _FileService_ReadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

// Client API for MetadataService service

type MetadataServiceClient interface {
	SetMetadata(ctx context.Context, in *SetMetadataRequest, opts ...grpc.CallOption) (*SetMetadataResponse, error)
	GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error)
	DeleteMetadata(ctx context.Context, in *DeleteMetadataRequest, opts ...grpc.CallOption) (*DeleteMetadataResponse, error)
	ListKeys(ctx context.Context, in *ListMetadataKeysRequest, opts ...grpc.CallOption) (MetadataService_ListKeysClient, error)
}

type metadataServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetadataServiceClient(cc *grpc.ClientConn) MetadataServiceClient {
	return &metadataServiceClient{cc}
}

func (c *metadataServiceClient) SetMetadata(ctx context.Context, in *SetMetadataRequest, opts ...grpc.CallOption) (*SetMetadataResponse, error) {
	out := new(SetMetadataResponse)
	err := grpc.Invoke(ctx, "/schema.MetadataService/SetMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error) {
	out := new(GetMetadataResponse)
	err := grpc.Invoke(ctx, "/schema.MetadataService/GetMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) DeleteMetadata(ctx context.Context, in *DeleteMetadataRequest, opts ...grpc.CallOption) (*DeleteMetadataResponse, error) {
	out := new(DeleteMetadataResponse)
	err := grpc.Invoke(ctx, "/schema.MetadataService/DeleteMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) ListKeys(ctx context.Context, in *ListMetadataKeysRequest, opts ...grpc.CallOption) (MetadataService_ListKeysClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MetadataService_serviceDesc.Streams[0], c.cc, "/schema.MetadataService/ListKeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &metadataServiceListKeysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MetadataService_ListKeysClient interface {
	Recv() (*ListMetadataKeysResponse, error)
	grpc.ClientStream
}

type metadataServiceListKeysClient struct {
	grpc.ClientStream
}

func (x *metadataServiceListKeysClient) Recv() (*ListMetadataKeysResponse, error) {
	m := new(ListMetadataKeysResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MetadataService service

type MetadataServiceServer interface {
	SetMetadata(context.Context, *SetMetadataRequest) (*SetMetadataResponse, error)
	GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataResponse, error)
	DeleteMetadata(context.Context, *DeleteMetadataRequest) (*DeleteMetadataResponse, error)
	ListKeys(*ListMetadataKeysRequest, MetadataService_ListKeysServer) error
}

func RegisterMetadataServiceServer(s *grpc.Server, srv MetadataServiceServer) {
	s.RegisterService(&_MetadataService_serviceDesc, srv)
}

func _MetadataService_SetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).SetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.MetadataService/SetMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).SetMetadata(ctx, req.(*SetMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_GetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).GetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.MetadataService/GetMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).GetMetadata(ctx, req.(*GetMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_DeleteMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).DeleteMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.MetadataService/DeleteMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).DeleteMetadata(ctx, req.(*DeleteMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_ListKeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListMetadataKeysRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetadataServiceServer).ListKeys(m, &metadataServiceListKeysServer{stream})
}

type MetadataService_ListKeysServer interface {
	Send(*ListMetadataKeysResponse) error
	grpc.ServerStream
}

type metadataServiceListKeysServer struct {
	grpc.ServerStream
}

func (x *metadataServiceListKeysServer) Send(m *ListMetadataKeysResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _MetadataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schema.MetadataService",
	HandlerType: (*MetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetMetadata",
			Handler:    _MetadataService_SetMetadata_Handler,
		},
		{
			MethodName: "GetMetadata",
			Handler:    _MetadataService_GetMetadata_Handler,
		},
		{
			MethodName: "DeleteMetadata",
			Handler:    _MetadataService_DeleteMetadata_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListKeys",
			Handler:       _MetadataService_ListKeys_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

// Client API for DataService service

type DataServiceClient interface {
	Write(ctx context.Context, in *DataWriteRequest, opts ...grpc.CallOption) (*DataWriteResponse, error)
	WriteFile(ctx context.Context, in *DataWriteFileRequest, opts ...grpc.CallOption) (*DataWriteFileResponse, error)
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (DataService_WriteStreamClient, error)
	Read(ctx context.Context, in *DataReadRequest, opts ...grpc.CallOption) (*DataReadResponse, error)
	ReadFile(ctx context.Context, in *DataReadFileRequest, opts ...grpc.CallOption) (*DataReadFileResponse, error)
	ReadStream(ctx context.Context, in *DataReadStreamRequest, opts ...grpc.CallOption) (DataService_ReadStreamClient, error)
	Delete(ctx context.Context, in *DataDeleteRequest, opts ...grpc.CallOption) (*DataDeleteResponse, error)
	Check(ctx context.Context, in *DataCheckRequest, opts ...grpc.CallOption) (*DataCheckResponse, error)
	Repair(ctx context.Context, in *DataRepairRequest, opts ...grpc.CallOption) (*DataRepairResponse, error)
}

type dataServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataServiceClient(cc *grpc.ClientConn) DataServiceClient {
	return &dataServiceClient{cc}
}

func (c *dataServiceClient) Write(ctx context.Context, in *DataWriteRequest, opts ...grpc.CallOption) (*DataWriteResponse, error) {
	out := new(DataWriteResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) WriteFile(ctx context.Context, in *DataWriteFileRequest, opts ...grpc.CallOption) (*DataWriteFileResponse, error) {
	out := new(DataWriteFileResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/WriteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (DataService_WriteStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataService_serviceDesc.Streams[0], c.cc, "/schema.DataService/WriteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceWriteStreamClient{stream}
	return x, nil
}

type DataService_WriteStreamClient interface {
	Send(*DataWriteStreamRequest) error
	CloseAndRecv() (*DataWriteStreamResponse, error)
	grpc.ClientStream
}

type dataServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *dataServiceWriteStreamClient) Send(m *DataWriteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataServiceWriteStreamClient) CloseAndRecv() (*DataWriteStreamResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DataWriteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) Read(ctx context.Context, in *DataReadRequest, opts ...grpc.CallOption) (*DataReadResponse, error) {
	out := new(DataReadResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ReadFile(ctx context.Context, in *DataReadFileRequest, opts ...grpc.CallOption) (*DataReadFileResponse, error) {
	out := new(DataReadFileResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/ReadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ReadStream(ctx context.Context, in *DataReadStreamRequest, opts ...grpc.CallOption) (DataService_ReadStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataService_serviceDesc.Streams[1], c.cc, "/schema.DataService/ReadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_ReadStreamClient interface {
	Recv() (*DataReadStreamResponse, error)
	grpc.ClientStream
}

type dataServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *dataServiceReadStreamClient) Recv() (*DataReadStreamResponse, error) {
	m := new(DataReadStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) Delete(ctx context.Context, in *DataDeleteRequest, opts ...grpc.CallOption) (*DataDeleteResponse, error) {
	out := new(DataDeleteResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) Check(ctx context.Context, in *DataCheckRequest, opts ...grpc.CallOption) (*DataCheckResponse, error) {
	out := new(DataCheckResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/Check", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) Repair(ctx context.Context, in *DataRepairRequest, opts ...grpc.CallOption) (*DataRepairResponse, error) {
	out := new(DataRepairResponse)
	err := grpc.Invoke(ctx, "/schema.DataService/Repair", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataService service

type DataServiceServer interface {
	Write(context.Context, *DataWriteRequest) (*DataWriteResponse, error)
	WriteFile(context.Context, *DataWriteFileRequest) (*DataWriteFileResponse, error)
	WriteStream(DataService_WriteStreamServer) error
	Read(context.Context, *DataReadRequest) (*DataReadResponse, error)
	ReadFile(context.Context, *DataReadFileRequest) (*DataReadFileResponse, error)
	ReadStream(*DataReadStreamRequest, DataService_ReadStreamServer) error
	Delete(context.Context, *DataDeleteRequest) (*DataDeleteResponse, error)
	Check(context.Context, *DataCheckRequest) (*DataCheckResponse, error)
	Repair(context.Context, *DataRepairRequest) (*DataRepairResponse, error)
}

func RegisterDataServiceServer(s *grpc.Server, srv DataServiceServer) {
	s.RegisterService(&_DataService_serviceDesc, srv)
}

func _DataService_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Write(ctx, req.(*DataWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataWriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/WriteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).WriteFile(ctx, req.(*DataWriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServiceServer).WriteStream(&dataServiceWriteStreamServer{stream})
}

type DataService_WriteStreamServer interface {
	SendAndClose(*DataWriteStreamResponse) error
	Recv() (*DataWriteStreamRequest, error)
	grpc.ServerStream
}

type dataServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *dataServiceWriteStreamServer) SendAndClose(m *DataWriteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataServiceWriteStreamServer) Recv() (*DataWriteStreamRequest, error) {
	m := new(DataWriteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Read(ctx, req.(*DataReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/ReadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ReadFile(ctx, req.(*DataReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DataReadStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).ReadStream(m, &dataServiceReadStreamServer{stream})
}

type DataService_ReadStreamServer interface {
	Send(*DataReadStreamResponse) error
	grpc.ServerStream
}

type dataServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *dataServiceReadStreamServer) Send(m *DataReadStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Delete(ctx, req.(*DataDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Check(ctx, req.(*DataCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_Repair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataRepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Repair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Repair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Repair(ctx, req.(*DataRepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schema.DataService",
	HandlerType: (*DataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _DataService_Write_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _DataService_WriteFile_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _DataService_Read_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _DataService_ReadFile_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DataService_Delete_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _DataService_Check_Handler,
		},
		{
			MethodName: "Repair",
			Handler:    _DataService_Repair_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteStream",
			Handler:       _DataService_WriteStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadStream",
			Handler:       _DataService_ReadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.TotalSize))
	}
	if m.CreationEpoch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.CreationEpoch))
	}
	if m.LastWriteEpoch != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.LastWriteEpoch))
	}
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChunkSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.ChunkSize))
	}
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.ShardID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.ShardID)))
		i += copy(dAtA[i:], m.ShardID)
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n1, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *WriteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	return i, nil
}

func (m *WriteFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteFileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *WriteStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		nn3, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *WriteStreamRequest_Metadata_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n4, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *WriteStreamRequest_Data_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Data.Size()))
		n5, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *WriteStreamRequest_Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *WriteStreamRequest_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i += copy(dAtA[i:], m.DataChunk)
	}
	return i, nil
}

func (m *WriteStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n6, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		nn7, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *ReadRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}
func (m *ReadRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n8, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ReadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		nn9, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	if m.FileMode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.FileMode))
	}
	if m.SynchronousIO {
		dAtA[i] = 0x28
		i++
		if m.SynchronousIO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReadFileRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}
func (m *ReadFileRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n10, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *ReadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReadStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		nn11, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.ChunkSize))
	}
	return i, nil
}

func (m *ReadStreamRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}
func (m *ReadStreamRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n12, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ReadStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i += copy(dAtA[i:], m.DataChunk)
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		nn13, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn13
	}
	return i, nil
}

func (m *DeleteRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}
func (m *DeleteRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n14, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		nn15, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.Fast {
		dAtA[i] = 0x18
		i++
		if m.Fast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CheckRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}
func (m *CheckRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Metadata != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n16, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *CheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *RepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *RepairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n17, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *SetMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n18, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SetMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *GetMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Metadata.Size()))
		n19, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *DeleteMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *DeleteMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListMetadataKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetadataKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListMetadataKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetadataKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *DataWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *DataWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataWriteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FilePath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	return i, nil
}

func (m *DataWriteFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteFileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataWriteStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i += copy(dAtA[i:], m.DataChunk)
	}
	return i, nil
}

func (m *DataWriteStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *DataReadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	if m.FileMode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.FileMode))
	}
	if m.SynchronousIO {
		dAtA[i] = 0x20
		i++
		if m.SynchronousIO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DataReadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DataReadStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.ChunkSize))
	}
	return i, nil
}

func (m *DataReadStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i += copy(dAtA[i:], m.DataChunk)
	}
	return i, nil
}

func (m *DataDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DataCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Fast {
		dAtA[i] = 0x10
		i++
		if m.Fast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DataCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDaemon(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *DataRepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRepairRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataRepairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRepairResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDaemon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintDaemon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovDaemon(uint64(m.TotalSize))
	}
	if m.CreationEpoch != 0 {
		n += 1 + sovDaemon(uint64(m.CreationEpoch))
	}
	if m.LastWriteEpoch != 0 {
		n += 1 + sovDaemon(uint64(m.LastWriteEpoch))
	}
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if m.ChunkSize != 0 {
		n += 1 + sovDaemon(uint64(m.ChunkSize))
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *Object) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.ShardID)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteFileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteFileResponse) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamRequest) Size() (n int) {
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *WriteStreamRequest_Metadata_) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *WriteStreamRequest_Data_) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *WriteStreamRequest_Metadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamRequest_Data) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamResponse) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *ReadRequest_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadRequest_Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.FileMode != 0 {
		n += 1 + sovDaemon(uint64(m.FileMode))
	}
	if m.SynchronousIO {
		n += 2
	}
	return n
}

func (m *ReadFileRequest_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadFileRequest_Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadFileResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReadStreamRequest) Size() (n int) {
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	if m.ChunkSize != 0 {
		n += 1 + sovDaemon(uint64(m.ChunkSize))
	}
	return n
}

func (m *ReadStreamRequest_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadStreamRequest_Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadStreamResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *DeleteRequest_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *DeleteRequest_Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *DeleteResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CheckRequest) Size() (n int) {
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	if m.Fast {
		n += 2
	}
	return n
}

func (m *CheckRequest_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *CheckRequest_Metadata) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *CheckResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDaemon(uint64(m.Status))
	}
	return n
}

func (m *RepairRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *RepairResponse) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *SetMetadataRequest) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *SetMetadataResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetMetadataRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *GetMetadataResponse) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteMetadataRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteMetadataResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListMetadataKeysRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListMetadataKeysResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataWriteFileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteFileResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataWriteStreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteStreamResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataReadRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataReadResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataReadFileRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.FileMode != 0 {
		n += 1 + sovDaemon(uint64(m.FileMode))
	}
	if m.SynchronousIO {
		n += 2
	}
	return n
}

func (m *DataReadFileResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DataReadStreamRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.ChunkSize != 0 {
		n += 1 + sovDaemon(uint64(m.ChunkSize))
	}
	return n
}

func (m *DataReadStreamResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataDeleteResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DataCheckRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.Fast {
		n += 2
	}
	return n
}

func (m *DataCheckResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDaemon(uint64(m.Status))
	}
	return n
}

func (m *DataRepairRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataRepairResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func sovDaemon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDaemon(x uint64) (n int) {
	return sovDaemon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Metadata{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`TotalSize:` + fmt.Sprintf("%v", this.TotalSize) + `,`,
		`CreationEpoch:` + fmt.Sprintf("%v", this.CreationEpoch) + `,`,
		`LastWriteEpoch:` + fmt.Sprintf("%v", this.LastWriteEpoch) + `,`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Chunk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Chunk{`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`Objects:` + strings.Replace(fmt.Sprintf("%v", this.Objects), "Object", "Object", 1) + `,`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Object) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Object{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ShardID:` + fmt.Sprintf("%v", this.ShardID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteResponse{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteFileRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteFileResponse{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Metadata_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Metadata_{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "WriteStreamRequest_Metadata", "WriteStreamRequest_Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Data_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Data_{`,
		`Data:` + strings.Replace(fmt.Sprintf("%v", this.Data), "WriteStreamRequest_Data", "WriteStreamRequest_Data", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Metadata{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Data) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Data{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamResponse{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadResponse{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`FileMode:` + fmt.Sprintf("%v", this.FileMode) + `,`,
		`SynchronousIO:` + fmt.Sprintf("%v", this.SynchronousIO) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamResponse{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteResponse{`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`Fast:` + fmt.Sprintf("%v", this.Fast) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepairRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepairRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepairResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepairResponse{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetMetadataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetMetadataRequest{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetMetadataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetMetadataResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetMetadataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetMetadataRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetMetadataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetMetadataResponse{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteMetadataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteMetadataRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteMetadataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteMetadataResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ListMetadataKeysRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetadataKeysRequest{`,
		`}`,
	}, "")
	return s
}
func (this *ListMetadataKeysResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetadataKeysResponse{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteRequest{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteResponse{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteFileRequest{`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteFileResponse{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteStreamRequest{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteStreamResponse{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadRequest{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadResponse{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadFileRequest{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`FileMode:` + fmt.Sprintf("%v", this.FileMode) + `,`,
		`SynchronousIO:` + fmt.Sprintf("%v", this.SynchronousIO) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadFileResponse{`,
		`}`,
	}, "")
	return s
}
func (this *DataReadStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadStreamRequest{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadStreamResponse{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataDeleteRequest{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataDeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataDeleteResponse{`,
		`}`,
	}, "")
	return s
}
func (this *DataCheckRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataCheckRequest{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`Fast:` + fmt.Sprintf("%v", this.Fast) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataCheckResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataCheckResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataRepairRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataRepairRequest{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataRepairResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataRepairResponse{`,
		`Chunks:` + strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDaemon(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpoch", wireType)
			}
			m.CreationEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWriteEpoch", wireType)
			}
			m.LastWriteEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastWriteEpoch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteStreamRequest_Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &WriteStreamRequest_Metadata_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteStreamRequest_Data{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &WriteStreamRequest_Data_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest_Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &ReadRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ReadRequest_Metadata{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &ReadFileRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ReadFileRequest_Metadata{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= (FileMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousIO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousIO = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &ReadStreamRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ReadStreamRequest_Metadata{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &DeleteRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &DeleteRequest_Metadata{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &CheckRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &CheckRequest_Metadata{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (CheckStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetadataKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetadataKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetadataKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetadataKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetadataKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetadataKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= (FileMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousIO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousIO = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (CheckStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataRepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataRepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRepairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataRepairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataRepairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDaemon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDaemon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDaemon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDaemon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDaemon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("schema/daemon.proto", fileDescriptorDaemon) }

var fileDescriptorDaemon = []byte{
	// 1370 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4d, 0x8f, 0xdb, 0xc4,
	0x1b, 0xb7, 0xf3, 0xd6, 0xf4, 0xc9, 0x4b, 0xb3, 0x93, 0x7d, 0xf1, 0xba, 0x5b, 0x77, 0xff, 0xfe,
	0x97, 0x2a, 0x94, 0x6a, 0x41, 0x69, 0xa9, 0x80, 0xc2, 0xd2, 0x7d, 0x69, 0xd3, 0x52, 0xaa, 0x05,
	0x07, 0x81, 0x84, 0x7a, 0x71, 0x9d, 0xa9, 0x62, 0x36, 0x1b, 0x87, 0xd8, 0xa9, 0x28, 0x07, 0xc4,
	0x99, 0x13, 0x1f, 0x83, 0x03, 0x12, 0xdf, 0x81, 0x13, 0x12, 0x12, 0xea, 0x11, 0x89, 0x0b, 0x0d,
	0x17, 0x8e, 0xfd, 0x08, 0xc8, 0xe3, 0x99, 0xf1, 0x8c, 0xed, 0xa4, 0x49, 0x29, 0x37, 0xe7, 0x79,
	0xf9, 0xcd, 0xf3, 0xf6, 0x7b, 0x66, 0x76, 0xa1, 0xe9, 0x3b, 0x7d, 0x7c, 0x62, 0xbf, 0xde, 0xb3,
	0xf1, 0x89, 0x37, 0xdc, 0x19, 0x8d, 0xbd, 0xc0, 0x43, 0xa5, 0x48, 0x68, 0xfe, 0xa4, 0x42, 0xf9,
	0x1e, 0x0e, 0xec, 0x9e, 0x1d, 0xd8, 0xa8, 0x01, 0xf9, 0x63, 0xfc, 0x58, 0x53, 0xb7, 0xd5, 0x56,
	0xd5, 0x0a, 0x3f, 0xd1, 0x16, 0x9c, 0x0e, 0xbc, 0xc0, 0x1e, 0x74, 0xdd, 0xaf, 0xb1, 0x96, 0xdb,
	0x56, 0x5b, 0x79, 0x2b, 0x16, 0xa0, 0x0b, 0x50, 0x73, 0xc6, 0xd8, 0x0e, 0x5c, 0x6f, 0x78, 0x73,
	0xe4, 0x39, 0x7d, 0x2d, 0x4f, 0x2c, 0x64, 0x21, 0xba, 0x08, 0xf5, 0x81, 0xed, 0x07, 0x9f, 0x8d,
	0xdd, 0x00, 0x47, 0x66, 0x05, 0x62, 0x96, 0x90, 0xa2, 0x57, 0xa0, 0xe4, 0xf4, 0x27, 0xc3, 0x63,
	0x5f, 0x2b, 0x6e, 0xe7, 0x5b, 0x95, 0x76, 0x6d, 0x27, 0x8a, 0x71, 0xe7, 0x20, 0x94, 0x5a, 0x54,
	0x69, 0x3a, 0x50, 0x24, 0x82, 0x30, 0x36, 0x22, 0x22, 0xb1, 0xa9, 0x51, 0x6c, 0x5c, 0x80, 0x5a,
	0x70, 0xca, 0x7b, 0xf0, 0x05, 0x76, 0x02, 0x5f, 0xcb, 0x11, 0xb8, 0x3a, 0x83, 0x3b, 0x22, 0x62,
	0x8b, 0xa9, 0x11, 0x82, 0x42, 0xdf, 0xf6, 0xa3, 0xe0, 0xab, 0x16, 0xf9, 0x36, 0xaf, 0x42, 0x29,
	0x32, 0xcb, 0xa8, 0x89, 0x06, 0xa7, 0xfc, 0xbe, 0x3d, 0xee, 0xdd, 0x39, 0x24, 0x15, 0x39, 0x6d,
	0xb1, 0x9f, 0xe6, 0x55, 0xa8, 0x92, 0x7c, 0x2c, 0xfc, 0xe5, 0x04, 0xfb, 0x59, 0xbe, 0x08, 0x0a,
	0x61, 0xa5, 0x89, 0x63, 0xd5, 0x22, 0xdf, 0xe6, 0x7b, 0x50, 0xa3, 0x5e, 0xfe, 0xc8, 0x1b, 0xfa,
	0x18, 0x5d, 0x86, 0xf2, 0x09, 0x6d, 0x09, 0xf1, 0xad, 0xb4, 0x1b, 0x2c, 0x76, 0xd6, 0x2a, 0x8b,
	0x5b, 0x98, 0x37, 0xa0, 0x41, 0xdc, 0x6f, 0xb9, 0x83, 0x39, 0x07, 0xeb, 0x50, 0x7e, 0xe8, 0x0e,
	0xf0, 0x47, 0x76, 0xd0, 0xa7, 0x51, 0xf3, 0xdf, 0xe6, 0x1e, 0xac, 0x08, 0x08, 0x2f, 0x14, 0xc4,
	0x1f, 0x2a, 0x20, 0x82, 0xd1, 0x0d, 0xc6, 0xd8, 0x3e, 0x61, 0x71, 0xec, 0xa5, 0x40, 0xfe, 0xcf,
	0x40, 0xd2, 0xd6, 0x1c, 0xf7, 0xb6, 0x12, 0x23, 0xa3, 0x37, 0x85, 0x8a, 0x55, 0xda, 0xe7, 0xe7,
	0xb8, 0x1f, 0x46, 0xae, 0xc4, 0x5c, 0xdf, 0x9a, 0x37, 0xd6, 0xfa, 0x05, 0x28, 0x84, 0xd6, 0xe1,
	0x08, 0x85, 0x16, 0x64, 0x9e, 0x68, 0x4f, 0x62, 0xc1, 0xfe, 0x29, 0x28, 0xba, 0xc3, 0xd1, 0x24,
	0x30, 0x0f, 0xa0, 0x29, 0x9d, 0xf7, 0x42, 0x25, 0xfa, 0x1c, 0x2a, 0x16, 0xb6, 0x7b, 0xac, 0x34,
	0x48, 0x08, 0xea, 0xb6, 0x12, 0x35, 0x69, 0x47, 0x00, 0xcc, 0x65, 0x03, 0x8a, 0xb5, 0x89, 0x03,
	0x34, 0xa1, 0x1a, 0x61, 0xd3, 0xc8, 0xd8, 0x98, 0xa9, 0xc2, 0x98, 0xfd, 0xa6, 0xc2, 0x99, 0xd0,
	0x48, 0x9c, 0x93, 0x97, 0x10, 0x84, 0x34, 0x59, 0x79, 0x79, 0xb2, 0xc2, 0x0a, 0x85, 0xdf, 0xf7,
	0xbc, 0x1e, 0x26, 0xa4, 0xaf, 0xc7, 0x58, 0xb7, 0xa8, 0xdc, 0xe2, 0x16, 0xe1, 0x3a, 0xf1, 0x1f,
	0x0f, 0x9d, 0xfe, 0xd8, 0x1b, 0x7a, 0x13, 0xff, 0xce, 0x91, 0x56, 0xdc, 0x56, 0x5b, 0x65, 0x4b,
	0x16, 0xc6, 0x49, 0x23, 0x68, 0xc4, 0xf9, 0x44, 0x89, 0x9b, 0xdf, 0xc0, 0x4a, 0x28, 0x93, 0xa7,
	0xf0, 0x65, 0x64, 0x29, 0x2d, 0x9b, 0x7c, 0x62, 0xd9, 0xc4, 0x31, 0xb5, 0x01, 0x89, 0xe7, 0xd3,
	0x76, 0x48, 0x63, 0xa6, 0x26, 0xc6, 0xcc, 0xbc, 0x0f, 0xb5, 0x43, 0x3c, 0xc0, 0x01, 0xfe, 0x4f,
	0x46, 0xa3, 0x01, 0x75, 0x86, 0x4e, 0x6b, 0xe4, 0x41, 0xf5, 0xa0, 0x8f, 0x9d, 0xe3, 0x97, 0x59,
	0x1e, 0x04, 0x85, 0x87, 0xb6, 0x1f, 0x90, 0xca, 0x94, 0x2d, 0xf2, 0x1d, 0x87, 0xf0, 0x2e, 0xd4,
	0xe8, 0x81, 0xb4, 0x1e, 0xaf, 0x41, 0xc9, 0x0f, 0xec, 0x60, 0xe2, 0x93, 0x43, 0xeb, 0xed, 0x66,
	0xbc, 0xe9, 0xb1, 0x73, 0xdc, 0x25, 0x2a, 0x8b, 0x9a, 0x98, 0xff, 0x83, 0x9a, 0x85, 0x47, 0xb6,
	0x3b, 0x9e, 0xb9, 0xdc, 0xcc, 0x5d, 0xa8, 0x33, 0x93, 0x17, 0xa2, 0xe6, 0x3e, 0xa0, 0x2e, 0x0e,
	0xb8, 0x82, 0x9e, 0xb3, 0x1c, 0xc6, 0x1a, 0x34, 0x25, 0x0c, 0x5a, 0xec, 0x8b, 0x80, 0x3a, 0x69,
	0xe8, 0x74, 0x0a, 0x07, 0xd0, 0xec, 0xa4, 0xdd, 0x97, 0x8c, 0xe1, 0x55, 0x58, 0x8b, 0x7a, 0xfd,
	0xfc, 0xf3, 0x34, 0x58, 0x4f, 0x9a, 0xd2, 0x88, 0x37, 0x61, 0xe3, 0x43, 0xd7, 0xe7, 0xa1, 0xdc,
	0xc5, 0x8f, 0x7d, 0x0a, 0x63, 0x5e, 0x06, 0x2d, 0xad, 0xa2, 0x91, 0xa6, 0x8f, 0xb8, 0x08, 0x8d,
	0x70, 0xc9, 0x4a, 0x37, 0x62, 0xd6, 0x62, 0x7a, 0x07, 0x56, 0x04, 0x3b, 0x0a, 0x17, 0x3f, 0x06,
	0xd4, 0x79, 0x8f, 0x81, 0x36, 0xac, 0x72, 0x5f, 0x71, 0xb1, 0x89, 0x4b, 0x49, 0x4d, 0x5c, 0x77,
	0xbb, 0xb0, 0x96, 0xf0, 0x59, 0xee, 0xcc, 0x6b, 0xb0, 0xce, 0xfd, 0xe5, 0x45, 0x33, 0x9f, 0xe7,
	0x37, 0x60, 0x23, 0xe5, 0xb7, 0xdc, 0xc9, 0x6f, 0xc1, 0x99, 0x43, 0xd2, 0xaa, 0xf8, 0x1a, 0x59,
	0xd0, 0x93, 0xf6, 0xe2, 0xb9, 0x97, 0xc4, 0x8f, 0x2a, 0x34, 0x99, 0xa1, 0x58, 0xcf, 0xc5, 0x8e,
	0x99, 0xf7, 0xca, 0x90, 0xee, 0x82, 0xfc, 0xf2, 0x77, 0x41, 0x21, 0xe3, 0x2e, 0x30, 0xd7, 0xa3,
	0xf6, 0xa7, 0xae, 0x81, 0xfb, 0x51, 0x8b, 0xd3, 0x57, 0xc1, 0x82, 0x79, 0x48, 0xdb, 0x3e, 0x97,
	0xd8, 0xf6, 0x6c, 0x00, 0x96, 0x5e, 0xf4, 0x74, 0xd0, 0xe5, 0x65, 0xbf, 0x60, 0x03, 0x57, 0x01,
	0x89, 0xbe, 0x34, 0xcf, 0x7b, 0x51, 0x5b, 0xa5, 0x75, 0xbe, 0x60, 0x8a, 0x6c, 0x63, 0xe7, 0xe2,
	0x8d, 0x6d, 0xde, 0x88, 0x02, 0xfc, 0x17, 0xcb, 0x9a, 0xa6, 0x28, 0x2f, 0xec, 0x05, 0x53, 0xbc,
	0x1e, 0xa5, 0x98, 0xd8, 0xe4, 0x8b, 0x39, 0x5f, 0xea, 0x42, 0x45, 0x88, 0x07, 0xad, 0x03, 0x12,
	0x7e, 0xde, 0x19, 0x3e, 0xb2, 0x07, 0x6e, 0xaf, 0xa1, 0xa0, 0x55, 0x68, 0x08, 0xf2, 0x4f, 0x89,
	0x54, 0x4d, 0x58, 0x1f, 0x8d, 0x02, 0xf7, 0xc4, 0x1e, 0x34, 0x72, 0x97, 0xee, 0x42, 0x99, 0x8d,
	0x66, 0xe8, 0xc9, 0xbe, 0x3f, 0x19, 0x4f, 0x86, 0x8e, 0x1d, 0xe0, 0x86, 0x82, 0x10, 0xd4, 0x99,
	0x74, 0x6f, 0x34, 0xc2, 0xc3, 0x10, 0x6d, 0x0d, 0x56, 0x98, 0xec, 0xe6, 0x57, 0xce, 0x60, 0xe2,
	0xbb, 0x8f, 0x70, 0x23, 0xd7, 0xfe, 0xb9, 0x00, 0x95, 0x50, 0xde, 0xc5, 0xe3, 0x47, 0xae, 0x83,
	0xd1, 0x35, 0x28, 0x92, 0x55, 0x80, 0x56, 0xa5, 0x37, 0x2d, 0x2d, 0x9a, 0xbe, 0x96, 0x90, 0xd2,
	0x8e, 0x2b, 0x68, 0x1f, 0x4e, 0xf3, 0xd5, 0x85, 0x34, 0xc9, 0x4a, 0x60, 0xac, 0xbe, 0x99, 0xa1,
	0xe1, 0x18, 0x1f, 0x40, 0x45, 0x58, 0x43, 0x48, 0x9f, 0xfd, 0xaa, 0xd6, 0xcf, 0x66, 0xea, 0x18,
	0x52, 0x4b, 0x45, 0x57, 0xa0, 0x10, 0x32, 0x01, 0xf1, 0xb9, 0x10, 0xd6, 0x93, 0xbe, 0x2a, 0x0b,
	0x79, 0x00, 0xef, 0x43, 0x99, 0x91, 0x16, 0x6d, 0x88, 0x36, 0x62, 0x0a, 0x5a, 0x5a, 0xc1, 0x01,
	0x3a, 0x00, 0x31, 0xff, 0xd0, 0xa6, 0x68, 0x29, 0xc7, 0xaf, 0x67, 0xa9, 0x18, 0xcc, 0x1b, 0x2a,
	0x7a, 0x1b, 0x4a, 0x11, 0xa9, 0x10, 0xaf, 0xb8, 0x44, 0x50, 0x7d, 0x3d, 0x29, 0xe6, 0x31, 0x5c,
	0x0b, 0xff, 0x12, 0xc5, 0xce, 0x71, 0xdc, 0x41, 0x91, 0x88, 0x71, 0x07, 0x25, 0x3e, 0x99, 0x4a,
	0x78, 0x64, 0x34, 0xe4, 0xf1, 0x91, 0x12, 0x61, 0xe2, 0x23, 0x65, 0x2e, 0x98, 0x4a, 0xfb, 0xd7,
	0x1c, 0x9c, 0x61, 0xd7, 0x2f, 0x1b, 0xa4, 0xdb, 0x50, 0x11, 0x5e, 0x1e, 0x71, 0x33, 0xd3, 0x4f,
	0x9a, 0xb8, 0x99, 0x59, 0x4f, 0x15, 0x25, 0x44, 0xea, 0x64, 0x21, 0x75, 0xe6, 0x20, 0x75, 0x32,
	0x91, 0x3e, 0x66, 0xaf, 0x4e, 0x0e, 0x76, 0x4e, 0x2e, 0x63, 0x12, 0xcf, 0x98, 0xa5, 0x16, 0x20,
	0xcb, 0xe1, 0xe3, 0x23, 0x7c, 0x74, 0x20, 0xfe, 0x67, 0xe0, 0x8c, 0x97, 0x8a, 0xbe, 0x3d, 0xdb,
	0x20, 0xee, 0x7d, 0xfb, 0xbb, 0x22, 0x54, 0x0e, 0x85, 0x4a, 0xee, 0x32, 0x4a, 0xf2, 0xc9, 0x4b,
	0x3e, 0x60, 0x62, 0x5a, 0xa5, 0x9e, 0x2c, 0x84, 0x56, 0x02, 0x35, 0xb7, 0x52, 0x96, 0xe2, 0x6c,
	0x9f, 0x9b, 0xa1, 0xe5, 0x58, 0x96, 0x4c, 0x51, 0x23, 0x65, 0x2f, 0x8f, 0xf9, 0xf9, 0x99, 0x7a,
	0x81, 0xaa, 0xd7, 0x29, 0x55, 0x37, 0x44, 0x63, 0x91, 0xae, 0x5a, 0x5a, 0x21, 0x30, 0x2e, 0xa6,
	0xec, 0xd9, 0xa4, 0x9d, 0x98, 0xda, 0x56, 0xb6, 0x92, 0x03, 0x1d, 0x49, 0xd4, 0x3d, 0x97, 0xb4,
	0x96, 0xf3, 0x32, 0x66, 0xa9, 0x05, 0x0a, 0xef, 0x71, 0x0a, 0x4b, 0xdd, 0x91, 0x69, 0xac, 0x67,
	0xa9, 0x78, 0x4c, 0xbb, 0x8c, 0xca, 0x52, 0x05, 0x24, 0x3a, 0x6f, 0x66, 0x68, 0xb8, 0xff, 0x1e,
	0xa7, 0xf4, 0xa6, 0x1c, 0xb0, 0x48, 0x6b, 0x3d, 0x4b, 0xc5, 0x20, 0xf6, 0x2f, 0x3f, 0x79, 0x6a,
	0x28, 0xbf, 0x3f, 0x35, 0x94, 0x67, 0x4f, 0x0d, 0xf5, 0xdb, 0xa9, 0xa1, 0xfe, 0x30, 0x35, 0xd4,
	0x5f, 0xa6, 0x86, 0xfa, 0x64, 0x6a, 0xa8, 0x7f, 0x4e, 0x0d, 0xf5, 0xef, 0xa9, 0xa1, 0x3c, 0x9b,
	0x1a, 0xea, 0xf7, 0x7f, 0x19, 0xca, 0x83, 0x12, 0xf9, 0x37, 0xde, 0x95, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0xbd, 0xc6, 0x1a, 0x27, 0xdd, 0x13, 0x00, 0x00,
}
