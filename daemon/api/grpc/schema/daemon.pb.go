// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema/daemon.proto

package schema

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CheckStatus int32

const (
	CheckStatusInvalid CheckStatus = 0
	CheckStatusValid   CheckStatus = 1
	CheckStatusOptimal CheckStatus = 2
)

var CheckStatus_name = map[int32]string{
	0: "CheckStatusInvalid",
	1: "CheckStatusValid",
	2: "CheckStatusOptimal",
}

var CheckStatus_value = map[string]int32{
	"CheckStatusInvalid": 0,
	"CheckStatusValid":   1,
	"CheckStatusOptimal": 2,
}

func (CheckStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{0}
}

type FileMode int32

const (
	// if the file already exists, truncate it to 0 bytes prior to writing
	FileModeTruncate FileMode = 0
	// append to the file should it already exists, otherwise create it
	FileModeAppend FileMode = 1
	// create a non-existing file and write to it
	FileModeExclusive FileMode = 2
)

var FileMode_name = map[int32]string{
	0: "FileModeTruncate",
	1: "FileModeAppend",
	2: "FileModeExclusive",
}

var FileMode_value = map[string]int32{
	"FileModeTruncate":  0,
	"FileModeAppend":    1,
	"FileModeExclusive": 2,
}

func (FileMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{1}
}

type Metadata struct {
	// key defines the key of the data,
	// and is chosen by the owner of this data.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// totalSize in bytes represents the total size of all chunks,
	// that make up the stored data, combined.
	TotalSize int64 `protobuf:"varint,2,opt,name=totalSize,proto3" json:"totalSize,omitempty"`
	// creationEpoch defines the time this data was initially created,
	// in the Unix epoch format, in nano seconds.
	CreationEpoch int64 `protobuf:"varint,3,opt,name=creationEpoch,proto3" json:"creationEpoch,omitempty"`
	// lastWriteEpoch defines the time this data
	// was last modified (e.g. repaired),
	// in the Unix epoch format, in nano seconds.
	LastWriteEpoch int64 `protobuf:"varint,4,opt,name=lastWriteEpoch,proto3" json:"lastWriteEpoch,omitempty"`
	// chunks is the metadata list of all chunks
	// that make up the data, when combined.
	Chunks []*Chunk `protobuf:"bytes,5,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *Metadata) Reset()      { *m = Metadata{} }
func (*Metadata) ProtoMessage() {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{0}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Metadata) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *Metadata) GetCreationEpoch() int64 {
	if m != nil {
		return m.CreationEpoch
	}
	return 0
}

func (m *Metadata) GetLastWriteEpoch() int64 {
	if m != nil {
		return m.LastWriteEpoch
	}
	return 0
}

func (m *Metadata) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type Chunk struct {
	// chunkSize of the chunk in bytes
	ChunkSize int64 `protobuf:"varint,1,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
	// objects defines the metadata of the objects
	// that make up this chunk.
	Objects []*Object `protobuf:"bytes,2,rep,name=objects,proto3" json:"objects,omitempty"`
	// hash contains the checksum/signature of the chunk (data),
	// meaning the data of all objects (of this chunk) combined.
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Chunk) Reset()      { *m = Chunk{} }
func (*Chunk) ProtoMessage() {}
func (*Chunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{1}
}
func (m *Chunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chunk.Merge(m, src)
}
func (m *Chunk) XXX_Size() int {
	return m.Size()
}
func (m *Chunk) XXX_DiscardUnknown() {
	xxx_messageInfo_Chunk.DiscardUnknown(m)
}

var xxx_messageInfo_Chunk proto.InternalMessageInfo

func (m *Chunk) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *Chunk) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *Chunk) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Object struct {
	// key of the Object
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// shardID defines the ID of the shard the object is stored on
	ShardID string `protobuf:"bytes,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
}

func (m *Object) Reset()      { *m = Object{} }
func (*Object) ProtoMessage() {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{2}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Object) GetShardID() string {
	if m != nil {
		return m.ShardID
	}
	return ""
}

type WriteRequest struct {
	Key  []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteRequest) Reset()      { *m = WriteRequest{} }
func (*WriteRequest) ProtoMessage() {}
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{3}
}
func (m *WriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteRequest.Merge(m, src)
}
func (m *WriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteRequest proto.InternalMessageInfo

func (m *WriteRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WriteResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *WriteResponse) Reset()      { *m = WriteResponse{} }
func (*WriteResponse) ProtoMessage() {}
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{4}
}
func (m *WriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteResponse.Merge(m, src)
}
func (m *WriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteResponse proto.InternalMessageInfo

func (m *WriteResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type WriteFileRequest struct {
	Key      []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	FilePath string `protobuf:"bytes,2,opt,name=filePath,proto3" json:"filePath,omitempty"`
}

func (m *WriteFileRequest) Reset()      { *m = WriteFileRequest{} }
func (*WriteFileRequest) ProtoMessage() {}
func (*WriteFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{5}
}
func (m *WriteFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteFileRequest.Merge(m, src)
}
func (m *WriteFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteFileRequest proto.InternalMessageInfo

func (m *WriteFileRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

type WriteFileResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *WriteFileResponse) Reset()      { *m = WriteFileResponse{} }
func (*WriteFileResponse) ProtoMessage() {}
func (*WriteFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{6}
}
func (m *WriteFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteFileResponse.Merge(m, src)
}
func (m *WriteFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteFileResponse proto.InternalMessageInfo

func (m *WriteFileResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// key is send as part of header
type WriteStreamRequest struct {
	// Types that are valid to be assigned to Input:
	//	*WriteStreamRequest_Metadata_
	//	*WriteStreamRequest_Data_
	Input isWriteStreamRequest_Input `protobuf_oneof:"input"`
}

func (m *WriteStreamRequest) Reset()      { *m = WriteStreamRequest{} }
func (*WriteStreamRequest) ProtoMessage() {}
func (*WriteStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{7}
}
func (m *WriteStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteStreamRequest.Merge(m, src)
}
func (m *WriteStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteStreamRequest proto.InternalMessageInfo

type isWriteStreamRequest_Input interface {
	isWriteStreamRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WriteStreamRequest_Metadata_ struct {
	Metadata *WriteStreamRequest_Metadata `protobuf:"bytes,1,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}
type WriteStreamRequest_Data_ struct {
	Data *WriteStreamRequest_Data `protobuf:"bytes,2,opt,name=data,proto3,oneof" json:"data,omitempty"`
}

func (*WriteStreamRequest_Metadata_) isWriteStreamRequest_Input() {}
func (*WriteStreamRequest_Data_) isWriteStreamRequest_Input()     {}

func (m *WriteStreamRequest) GetInput() isWriteStreamRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *WriteStreamRequest) GetMetadata() *WriteStreamRequest_Metadata {
	if x, ok := m.GetInput().(*WriteStreamRequest_Metadata_); ok {
		return x.Metadata
	}
	return nil
}

func (m *WriteStreamRequest) GetData() *WriteStreamRequest_Data {
	if x, ok := m.GetInput().(*WriteStreamRequest_Data_); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WriteStreamRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WriteStreamRequest_Metadata_)(nil),
		(*WriteStreamRequest_Data_)(nil),
	}
}

type WriteStreamRequest_Metadata struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *WriteStreamRequest_Metadata) Reset()      { *m = WriteStreamRequest_Metadata{} }
func (*WriteStreamRequest_Metadata) ProtoMessage() {}
func (*WriteStreamRequest_Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{7, 0}
}
func (m *WriteStreamRequest_Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteStreamRequest_Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteStreamRequest_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteStreamRequest_Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteStreamRequest_Metadata.Merge(m, src)
}
func (m *WriteStreamRequest_Metadata) XXX_Size() int {
	return m.Size()
}
func (m *WriteStreamRequest_Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteStreamRequest_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_WriteStreamRequest_Metadata proto.InternalMessageInfo

func (m *WriteStreamRequest_Metadata) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type WriteStreamRequest_Data struct {
	DataChunk []byte `protobuf:"bytes,2,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *WriteStreamRequest_Data) Reset()      { *m = WriteStreamRequest_Data{} }
func (*WriteStreamRequest_Data) ProtoMessage() {}
func (*WriteStreamRequest_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{7, 1}
}
func (m *WriteStreamRequest_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteStreamRequest_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteStreamRequest_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteStreamRequest_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteStreamRequest_Data.Merge(m, src)
}
func (m *WriteStreamRequest_Data) XXX_Size() int {
	return m.Size()
}
func (m *WriteStreamRequest_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteStreamRequest_Data.DiscardUnknown(m)
}

var xxx_messageInfo_WriteStreamRequest_Data proto.InternalMessageInfo

func (m *WriteStreamRequest_Data) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type WriteStreamResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *WriteStreamResponse) Reset()      { *m = WriteStreamResponse{} }
func (*WriteStreamResponse) ProtoMessage() {}
func (*WriteStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{8}
}
func (m *WriteStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteStreamResponse.Merge(m, src)
}
func (m *WriteStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteStreamResponse proto.InternalMessageInfo

func (m *WriteStreamResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ReadRequest struct {
	// Types that are valid to be assigned to Input:
	//	*ReadRequest_Key
	//	*ReadRequest_Metadata
	Input isReadRequest_Input `protobuf_oneof:"input"`
}

func (m *ReadRequest) Reset()      { *m = ReadRequest{} }
func (*ReadRequest) ProtoMessage() {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{9}
}
func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(m, src)
}
func (m *ReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

type isReadRequest_Input interface {
	isReadRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
}
type ReadRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}

func (*ReadRequest_Key) isReadRequest_Input()      {}
func (*ReadRequest_Metadata) isReadRequest_Input() {}

func (m *ReadRequest) GetInput() isReadRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ReadRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*ReadRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *ReadRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*ReadRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadRequest_Key)(nil),
		(*ReadRequest_Metadata)(nil),
	}
}

type ReadResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReadResponse) Reset()      { *m = ReadResponse{} }
func (*ReadResponse) ProtoMessage() {}
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{10}
}
func (m *ReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResponse.Merge(m, src)
}
func (m *ReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResponse proto.InternalMessageInfo

func (m *ReadResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ReadFileRequest struct {
	// Types that are valid to be assigned to Input:
	//	*ReadFileRequest_Key
	//	*ReadFileRequest_Metadata
	Input isReadFileRequest_Input `protobuf_oneof:"input"`
	// destination file and its configuration
	FilePath      string   `protobuf:"bytes,3,opt,name=filePath,proto3" json:"filePath,omitempty"`
	FileMode      FileMode `protobuf:"varint,4,opt,name=fileMode,proto3,enum=schema.FileMode" json:"fileMode,omitempty"`
	SynchronousIO bool     `protobuf:"varint,5,opt,name=synchronousIO,proto3" json:"synchronousIO,omitempty"`
}

func (m *ReadFileRequest) Reset()      { *m = ReadFileRequest{} }
func (*ReadFileRequest) ProtoMessage() {}
func (*ReadFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{11}
}
func (m *ReadFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadFileRequest.Merge(m, src)
}
func (m *ReadFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadFileRequest proto.InternalMessageInfo

type isReadFileRequest_Input interface {
	isReadFileRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadFileRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
}
type ReadFileRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}

func (*ReadFileRequest_Key) isReadFileRequest_Input()      {}
func (*ReadFileRequest_Metadata) isReadFileRequest_Input() {}

func (m *ReadFileRequest) GetInput() isReadFileRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ReadFileRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*ReadFileRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *ReadFileRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*ReadFileRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *ReadFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *ReadFileRequest) GetFileMode() FileMode {
	if m != nil {
		return m.FileMode
	}
	return FileModeTruncate
}

func (m *ReadFileRequest) GetSynchronousIO() bool {
	if m != nil {
		return m.SynchronousIO
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadFileRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadFileRequest_Key)(nil),
		(*ReadFileRequest_Metadata)(nil),
	}
}

type ReadFileResponse struct {
}

func (m *ReadFileResponse) Reset()      { *m = ReadFileResponse{} }
func (*ReadFileResponse) ProtoMessage() {}
func (*ReadFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{12}
}
func (m *ReadFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadFileResponse.Merge(m, src)
}
func (m *ReadFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadFileResponse proto.InternalMessageInfo

type ReadStreamRequest struct {
	// Types that are valid to be assigned to Input:
	//	*ReadStreamRequest_Key
	//	*ReadStreamRequest_Metadata
	Input     isReadStreamRequest_Input `protobuf_oneof:"input"`
	ChunkSize int64                     `protobuf:"varint,3,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
}

func (m *ReadStreamRequest) Reset()      { *m = ReadStreamRequest{} }
func (*ReadStreamRequest) ProtoMessage() {}
func (*ReadStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{13}
}
func (m *ReadStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadStreamRequest.Merge(m, src)
}
func (m *ReadStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadStreamRequest proto.InternalMessageInfo

type isReadStreamRequest_Input interface {
	isReadStreamRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadStreamRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
}
type ReadStreamRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}

func (*ReadStreamRequest_Key) isReadStreamRequest_Input()      {}
func (*ReadStreamRequest_Metadata) isReadStreamRequest_Input() {}

func (m *ReadStreamRequest) GetInput() isReadStreamRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ReadStreamRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*ReadStreamRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *ReadStreamRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*ReadStreamRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *ReadStreamRequest) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReadStreamRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReadStreamRequest_Key)(nil),
		(*ReadStreamRequest_Metadata)(nil),
	}
}

type ReadStreamResponse struct {
	DataChunk []byte `protobuf:"bytes,1,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *ReadStreamResponse) Reset()      { *m = ReadStreamResponse{} }
func (*ReadStreamResponse) ProtoMessage() {}
func (*ReadStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{14}
}
func (m *ReadStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadStreamResponse.Merge(m, src)
}
func (m *ReadStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadStreamResponse proto.InternalMessageInfo

func (m *ReadStreamResponse) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DeleteRequest struct {
	// Types that are valid to be assigned to Input:
	//	*DeleteRequest_Key
	//	*DeleteRequest_Metadata
	Input isDeleteRequest_Input `protobuf_oneof:"input"`
}

func (m *DeleteRequest) Reset()      { *m = DeleteRequest{} }
func (*DeleteRequest) ProtoMessage() {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{15}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(m, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

type isDeleteRequest_Input interface {
	isDeleteRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DeleteRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
}
type DeleteRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}

func (*DeleteRequest_Key) isDeleteRequest_Input()      {}
func (*DeleteRequest_Metadata) isDeleteRequest_Input() {}

func (m *DeleteRequest) GetInput() isDeleteRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *DeleteRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*DeleteRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *DeleteRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*DeleteRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeleteRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeleteRequest_Key)(nil),
		(*DeleteRequest_Metadata)(nil),
	}
}

type DeleteResponse struct {
}

func (m *DeleteResponse) Reset()      { *m = DeleteResponse{} }
func (*DeleteResponse) ProtoMessage() {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{16}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(m, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

type CheckRequest struct {
	// Types that are valid to be assigned to Input:
	//	*CheckRequest_Key
	//	*CheckRequest_Metadata
	Input isCheckRequest_Input `protobuf_oneof:"input"`
	Fast  bool                 `protobuf:"varint,3,opt,name=fast,proto3" json:"fast,omitempty"`
}

func (m *CheckRequest) Reset()      { *m = CheckRequest{} }
func (*CheckRequest) ProtoMessage() {}
func (*CheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{17}
}
func (m *CheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckRequest.Merge(m, src)
}
func (m *CheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckRequest proto.InternalMessageInfo

type isCheckRequest_Input interface {
	isCheckRequest_Input()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CheckRequest_Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
}
type CheckRequest_Metadata struct {
	Metadata *Metadata `protobuf:"bytes,2,opt,name=metadata,proto3,oneof" json:"metadata,omitempty"`
}

func (*CheckRequest_Key) isCheckRequest_Input()      {}
func (*CheckRequest_Metadata) isCheckRequest_Input() {}

func (m *CheckRequest) GetInput() isCheckRequest_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CheckRequest) GetKey() []byte {
	if x, ok := m.GetInput().(*CheckRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *CheckRequest) GetMetadata() *Metadata {
	if x, ok := m.GetInput().(*CheckRequest_Metadata); ok {
		return x.Metadata
	}
	return nil
}

func (m *CheckRequest) GetFast() bool {
	if m != nil {
		return m.Fast
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CheckRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CheckRequest_Key)(nil),
		(*CheckRequest_Metadata)(nil),
	}
}

type CheckResponse struct {
	Status CheckStatus `protobuf:"varint,1,opt,name=status,proto3,enum=schema.CheckStatus" json:"status,omitempty"`
}

func (m *CheckResponse) Reset()      { *m = CheckResponse{} }
func (*CheckResponse) ProtoMessage() {}
func (*CheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{18}
}
func (m *CheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckResponse.Merge(m, src)
}
func (m *CheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckResponse proto.InternalMessageInfo

func (m *CheckResponse) GetStatus() CheckStatus {
	if m != nil {
		return m.Status
	}
	return CheckStatusInvalid
}

type RepairRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *RepairRequest) Reset()      { *m = RepairRequest{} }
func (*RepairRequest) ProtoMessage() {}
func (*RepairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{19}
}
func (m *RepairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepairRequest.Merge(m, src)
}
func (m *RepairRequest) XXX_Size() int {
	return m.Size()
}
func (m *RepairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RepairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RepairRequest proto.InternalMessageInfo

func (m *RepairRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type RepairResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *RepairResponse) Reset()      { *m = RepairResponse{} }
func (*RepairResponse) ProtoMessage() {}
func (*RepairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{20}
}
func (m *RepairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepairResponse.Merge(m, src)
}
func (m *RepairResponse) XXX_Size() int {
	return m.Size()
}
func (m *RepairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RepairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RepairResponse proto.InternalMessageInfo

func (m *RepairResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type SetMetadataRequest struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *SetMetadataRequest) Reset()      { *m = SetMetadataRequest{} }
func (*SetMetadataRequest) ProtoMessage() {}
func (*SetMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{21}
}
func (m *SetMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMetadataRequest.Merge(m, src)
}
func (m *SetMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetMetadataRequest proto.InternalMessageInfo

func (m *SetMetadataRequest) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type SetMetadataResponse struct {
}

func (m *SetMetadataResponse) Reset()      { *m = SetMetadataResponse{} }
func (*SetMetadataResponse) ProtoMessage() {}
func (*SetMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{22}
}
func (m *SetMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMetadataResponse.Merge(m, src)
}
func (m *SetMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetMetadataResponse proto.InternalMessageInfo

type GetMetadataRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetMetadataRequest) Reset()      { *m = GetMetadataRequest{} }
func (*GetMetadataRequest) ProtoMessage() {}
func (*GetMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{23}
}
func (m *GetMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMetadataRequest.Merge(m, src)
}
func (m *GetMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMetadataRequest proto.InternalMessageInfo

func (m *GetMetadataRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type GetMetadataResponse struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *GetMetadataResponse) Reset()      { *m = GetMetadataResponse{} }
func (*GetMetadataResponse) ProtoMessage() {}
func (*GetMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{24}
}
func (m *GetMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMetadataResponse.Merge(m, src)
}
func (m *GetMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMetadataResponse proto.InternalMessageInfo

func (m *GetMetadataResponse) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type DeleteMetadataRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DeleteMetadataRequest) Reset()      { *m = DeleteMetadataRequest{} }
func (*DeleteMetadataRequest) ProtoMessage() {}
func (*DeleteMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{25}
}
func (m *DeleteMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMetadataRequest.Merge(m, src)
}
func (m *DeleteMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMetadataRequest proto.InternalMessageInfo

func (m *DeleteMetadataRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DeleteMetadataResponse struct {
}

func (m *DeleteMetadataResponse) Reset()      { *m = DeleteMetadataResponse{} }
func (*DeleteMetadataResponse) ProtoMessage() {}
func (*DeleteMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{26}
}
func (m *DeleteMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMetadataResponse.Merge(m, src)
}
func (m *DeleteMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMetadataResponse proto.InternalMessageInfo

type ListMetadataKeysRequest struct {
}

func (m *ListMetadataKeysRequest) Reset()      { *m = ListMetadataKeysRequest{} }
func (*ListMetadataKeysRequest) ProtoMessage() {}
func (*ListMetadataKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{27}
}
func (m *ListMetadataKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMetadataKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMetadataKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMetadataKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMetadataKeysRequest.Merge(m, src)
}
func (m *ListMetadataKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListMetadataKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMetadataKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListMetadataKeysRequest proto.InternalMessageInfo

type ListMetadataKeysResponse struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ListMetadataKeysResponse) Reset()      { *m = ListMetadataKeysResponse{} }
func (*ListMetadataKeysResponse) ProtoMessage() {}
func (*ListMetadataKeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{28}
}
func (m *ListMetadataKeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMetadataKeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMetadataKeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMetadataKeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMetadataKeysResponse.Merge(m, src)
}
func (m *ListMetadataKeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListMetadataKeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMetadataKeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMetadataKeysResponse proto.InternalMessageInfo

func (m *ListMetadataKeysResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DataWriteRequest struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataWriteRequest) Reset()      { *m = DataWriteRequest{} }
func (*DataWriteRequest) ProtoMessage() {}
func (*DataWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{29}
}
func (m *DataWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataWriteRequest.Merge(m, src)
}
func (m *DataWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataWriteRequest proto.InternalMessageInfo

func (m *DataWriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DataWriteResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataWriteResponse) Reset()      { *m = DataWriteResponse{} }
func (*DataWriteResponse) ProtoMessage() {}
func (*DataWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{30}
}
func (m *DataWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataWriteResponse.Merge(m, src)
}
func (m *DataWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataWriteResponse proto.InternalMessageInfo

func (m *DataWriteResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataWriteFileRequest struct {
	FilePath string `protobuf:"bytes,1,opt,name=filePath,proto3" json:"filePath,omitempty"`
}

func (m *DataWriteFileRequest) Reset()      { *m = DataWriteFileRequest{} }
func (*DataWriteFileRequest) ProtoMessage() {}
func (*DataWriteFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{31}
}
func (m *DataWriteFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataWriteFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataWriteFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataWriteFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataWriteFileRequest.Merge(m, src)
}
func (m *DataWriteFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataWriteFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataWriteFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataWriteFileRequest proto.InternalMessageInfo

func (m *DataWriteFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

type DataWriteFileResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataWriteFileResponse) Reset()      { *m = DataWriteFileResponse{} }
func (*DataWriteFileResponse) ProtoMessage() {}
func (*DataWriteFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{32}
}
func (m *DataWriteFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataWriteFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataWriteFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataWriteFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataWriteFileResponse.Merge(m, src)
}
func (m *DataWriteFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataWriteFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataWriteFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataWriteFileResponse proto.InternalMessageInfo

func (m *DataWriteFileResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataWriteStreamRequest struct {
	DataChunk []byte `protobuf:"bytes,1,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *DataWriteStreamRequest) Reset()      { *m = DataWriteStreamRequest{} }
func (*DataWriteStreamRequest) ProtoMessage() {}
func (*DataWriteStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{33}
}
func (m *DataWriteStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataWriteStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataWriteStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataWriteStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataWriteStreamRequest.Merge(m, src)
}
func (m *DataWriteStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataWriteStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataWriteStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataWriteStreamRequest proto.InternalMessageInfo

func (m *DataWriteStreamRequest) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DataWriteStreamResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataWriteStreamResponse) Reset()      { *m = DataWriteStreamResponse{} }
func (*DataWriteStreamResponse) ProtoMessage() {}
func (*DataWriteStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{34}
}
func (m *DataWriteStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataWriteStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataWriteStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataWriteStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataWriteStreamResponse.Merge(m, src)
}
func (m *DataWriteStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataWriteStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataWriteStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataWriteStreamResponse proto.InternalMessageInfo

func (m *DataWriteStreamResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataReadRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataReadRequest) Reset()      { *m = DataReadRequest{} }
func (*DataReadRequest) ProtoMessage() {}
func (*DataReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{35}
}
func (m *DataReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReadRequest.Merge(m, src)
}
func (m *DataReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataReadRequest proto.InternalMessageInfo

func (m *DataReadRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataReadResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DataReadResponse) Reset()      { *m = DataReadResponse{} }
func (*DataReadResponse) ProtoMessage() {}
func (*DataReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{36}
}
func (m *DataReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReadResponse.Merge(m, src)
}
func (m *DataReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataReadResponse proto.InternalMessageInfo

func (m *DataReadResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DataReadFileRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
	// destination file and its configuration
	FilePath      string   `protobuf:"bytes,2,opt,name=filePath,proto3" json:"filePath,omitempty"`
	FileMode      FileMode `protobuf:"varint,3,opt,name=fileMode,proto3,enum=schema.FileMode" json:"fileMode,omitempty"`
	SynchronousIO bool     `protobuf:"varint,4,opt,name=synchronousIO,proto3" json:"synchronousIO,omitempty"`
}

func (m *DataReadFileRequest) Reset()      { *m = DataReadFileRequest{} }
func (*DataReadFileRequest) ProtoMessage() {}
func (*DataReadFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{37}
}
func (m *DataReadFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReadFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReadFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReadFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReadFileRequest.Merge(m, src)
}
func (m *DataReadFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataReadFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReadFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataReadFileRequest proto.InternalMessageInfo

func (m *DataReadFileRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *DataReadFileRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *DataReadFileRequest) GetFileMode() FileMode {
	if m != nil {
		return m.FileMode
	}
	return FileModeTruncate
}

func (m *DataReadFileRequest) GetSynchronousIO() bool {
	if m != nil {
		return m.SynchronousIO
	}
	return false
}

type DataReadFileResponse struct {
}

func (m *DataReadFileResponse) Reset()      { *m = DataReadFileResponse{} }
func (*DataReadFileResponse) ProtoMessage() {}
func (*DataReadFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{38}
}
func (m *DataReadFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReadFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReadFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReadFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReadFileResponse.Merge(m, src)
}
func (m *DataReadFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataReadFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReadFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataReadFileResponse proto.InternalMessageInfo

type DataReadStreamRequest struct {
	Chunks    []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
	ChunkSize int64    `protobuf:"varint,2,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
}

func (m *DataReadStreamRequest) Reset()      { *m = DataReadStreamRequest{} }
func (*DataReadStreamRequest) ProtoMessage() {}
func (*DataReadStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{39}
}
func (m *DataReadStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReadStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReadStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReadStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReadStreamRequest.Merge(m, src)
}
func (m *DataReadStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataReadStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReadStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataReadStreamRequest proto.InternalMessageInfo

func (m *DataReadStreamRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *DataReadStreamRequest) GetChunkSize() int64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

type DataReadStreamResponse struct {
	DataChunk []byte `protobuf:"bytes,1,opt,name=dataChunk,proto3" json:"dataChunk,omitempty"`
}

func (m *DataReadStreamResponse) Reset()      { *m = DataReadStreamResponse{} }
func (*DataReadStreamResponse) ProtoMessage() {}
func (*DataReadStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{40}
}
func (m *DataReadStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReadStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReadStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReadStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReadStreamResponse.Merge(m, src)
}
func (m *DataReadStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataReadStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReadStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataReadStreamResponse proto.InternalMessageInfo

func (m *DataReadStreamResponse) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

type DataDeleteRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataDeleteRequest) Reset()      { *m = DataDeleteRequest{} }
func (*DataDeleteRequest) ProtoMessage() {}
func (*DataDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{41}
}
func (m *DataDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDeleteRequest.Merge(m, src)
}
func (m *DataDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataDeleteRequest proto.InternalMessageInfo

func (m *DataDeleteRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataDeleteResponse struct {
}

func (m *DataDeleteResponse) Reset()      { *m = DataDeleteResponse{} }
func (*DataDeleteResponse) ProtoMessage() {}
func (*DataDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{42}
}
func (m *DataDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDeleteResponse.Merge(m, src)
}
func (m *DataDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataDeleteResponse proto.InternalMessageInfo

type DataCheckRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
	Fast   bool     `protobuf:"varint,2,opt,name=fast,proto3" json:"fast,omitempty"`
}

func (m *DataCheckRequest) Reset()      { *m = DataCheckRequest{} }
func (*DataCheckRequest) ProtoMessage() {}
func (*DataCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{43}
}
func (m *DataCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataCheckRequest.Merge(m, src)
}
func (m *DataCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataCheckRequest proto.InternalMessageInfo

func (m *DataCheckRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *DataCheckRequest) GetFast() bool {
	if m != nil {
		return m.Fast
	}
	return false
}

type DataCheckResponse struct {
	Status CheckStatus `protobuf:"varint,1,opt,name=status,proto3,enum=schema.CheckStatus" json:"status,omitempty"`
}

func (m *DataCheckResponse) Reset()      { *m = DataCheckResponse{} }
func (*DataCheckResponse) ProtoMessage() {}
func (*DataCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{44}
}
func (m *DataCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataCheckResponse.Merge(m, src)
}
func (m *DataCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataCheckResponse proto.InternalMessageInfo

func (m *DataCheckResponse) GetStatus() CheckStatus {
	if m != nil {
		return m.Status
	}
	return CheckStatusInvalid
}

type DataRepairRequest struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataRepairRequest) Reset()      { *m = DataRepairRequest{} }
func (*DataRepairRequest) ProtoMessage() {}
func (*DataRepairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{45}
}
func (m *DataRepairRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRepairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRepairRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRepairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRepairRequest.Merge(m, src)
}
func (m *DataRepairRequest) XXX_Size() int {
	return m.Size()
}
func (m *DataRepairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRepairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DataRepairRequest proto.InternalMessageInfo

func (m *DataRepairRequest) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type DataRepairResponse struct {
	Chunks []*Chunk `protobuf:"bytes,1,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *DataRepairResponse) Reset()      { *m = DataRepairResponse{} }
func (*DataRepairResponse) ProtoMessage() {}
func (*DataRepairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_79298d76542483a2, []int{46}
}
func (m *DataRepairResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataRepairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataRepairResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataRepairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataRepairResponse.Merge(m, src)
}
func (m *DataRepairResponse) XXX_Size() int {
	return m.Size()
}
func (m *DataRepairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DataRepairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DataRepairResponse proto.InternalMessageInfo

func (m *DataRepairResponse) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func init() {
	proto.RegisterEnum("schema.CheckStatus", CheckStatus_name, CheckStatus_value)
	proto.RegisterEnum("schema.FileMode", FileMode_name, FileMode_value)
	proto.RegisterType((*Metadata)(nil), "schema.Metadata")
	proto.RegisterType((*Chunk)(nil), "schema.Chunk")
	proto.RegisterType((*Object)(nil), "schema.Object")
	proto.RegisterType((*WriteRequest)(nil), "schema.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "schema.WriteResponse")
	proto.RegisterType((*WriteFileRequest)(nil), "schema.WriteFileRequest")
	proto.RegisterType((*WriteFileResponse)(nil), "schema.WriteFileResponse")
	proto.RegisterType((*WriteStreamRequest)(nil), "schema.WriteStreamRequest")
	proto.RegisterType((*WriteStreamRequest_Metadata)(nil), "schema.WriteStreamRequest.Metadata")
	proto.RegisterType((*WriteStreamRequest_Data)(nil), "schema.WriteStreamRequest.Data")
	proto.RegisterType((*WriteStreamResponse)(nil), "schema.WriteStreamResponse")
	proto.RegisterType((*ReadRequest)(nil), "schema.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "schema.ReadResponse")
	proto.RegisterType((*ReadFileRequest)(nil), "schema.ReadFileRequest")
	proto.RegisterType((*ReadFileResponse)(nil), "schema.ReadFileResponse")
	proto.RegisterType((*ReadStreamRequest)(nil), "schema.ReadStreamRequest")
	proto.RegisterType((*ReadStreamResponse)(nil), "schema.ReadStreamResponse")
	proto.RegisterType((*DeleteRequest)(nil), "schema.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "schema.DeleteResponse")
	proto.RegisterType((*CheckRequest)(nil), "schema.CheckRequest")
	proto.RegisterType((*CheckResponse)(nil), "schema.CheckResponse")
	proto.RegisterType((*RepairRequest)(nil), "schema.RepairRequest")
	proto.RegisterType((*RepairResponse)(nil), "schema.RepairResponse")
	proto.RegisterType((*SetMetadataRequest)(nil), "schema.SetMetadataRequest")
	proto.RegisterType((*SetMetadataResponse)(nil), "schema.SetMetadataResponse")
	proto.RegisterType((*GetMetadataRequest)(nil), "schema.GetMetadataRequest")
	proto.RegisterType((*GetMetadataResponse)(nil), "schema.GetMetadataResponse")
	proto.RegisterType((*DeleteMetadataRequest)(nil), "schema.DeleteMetadataRequest")
	proto.RegisterType((*DeleteMetadataResponse)(nil), "schema.DeleteMetadataResponse")
	proto.RegisterType((*ListMetadataKeysRequest)(nil), "schema.ListMetadataKeysRequest")
	proto.RegisterType((*ListMetadataKeysResponse)(nil), "schema.ListMetadataKeysResponse")
	proto.RegisterType((*DataWriteRequest)(nil), "schema.DataWriteRequest")
	proto.RegisterType((*DataWriteResponse)(nil), "schema.DataWriteResponse")
	proto.RegisterType((*DataWriteFileRequest)(nil), "schema.DataWriteFileRequest")
	proto.RegisterType((*DataWriteFileResponse)(nil), "schema.DataWriteFileResponse")
	proto.RegisterType((*DataWriteStreamRequest)(nil), "schema.DataWriteStreamRequest")
	proto.RegisterType((*DataWriteStreamResponse)(nil), "schema.DataWriteStreamResponse")
	proto.RegisterType((*DataReadRequest)(nil), "schema.DataReadRequest")
	proto.RegisterType((*DataReadResponse)(nil), "schema.DataReadResponse")
	proto.RegisterType((*DataReadFileRequest)(nil), "schema.DataReadFileRequest")
	proto.RegisterType((*DataReadFileResponse)(nil), "schema.DataReadFileResponse")
	proto.RegisterType((*DataReadStreamRequest)(nil), "schema.DataReadStreamRequest")
	proto.RegisterType((*DataReadStreamResponse)(nil), "schema.DataReadStreamResponse")
	proto.RegisterType((*DataDeleteRequest)(nil), "schema.DataDeleteRequest")
	proto.RegisterType((*DataDeleteResponse)(nil), "schema.DataDeleteResponse")
	proto.RegisterType((*DataCheckRequest)(nil), "schema.DataCheckRequest")
	proto.RegisterType((*DataCheckResponse)(nil), "schema.DataCheckResponse")
	proto.RegisterType((*DataRepairRequest)(nil), "schema.DataRepairRequest")
	proto.RegisterType((*DataRepairResponse)(nil), "schema.DataRepairResponse")
}

func init() { proto.RegisterFile("schema/daemon.proto", fileDescriptor_79298d76542483a2) }

var fileDescriptor_79298d76542483a2 = []byte{
	// 1379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4d, 0x8f, 0xdb, 0xc4,
	0x1b, 0xb7, 0x93, 0x6c, 0x9a, 0x3e, 0x79, 0x69, 0x76, 0xb2, 0x2f, 0x5e, 0x77, 0xeb, 0xee, 0xdf,
	0xff, 0x52, 0x85, 0x52, 0x2d, 0x28, 0x2d, 0x15, 0x50, 0x58, 0xba, 0x2f, 0x6d, 0x5a, 0x4a, 0xb5,
	0xe0, 0x20, 0x90, 0x50, 0x2f, 0xae, 0x33, 0x55, 0xcc, 0x66, 0xe3, 0x10, 0x3b, 0x15, 0xe5, 0x80,
	0x38, 0x73, 0xe2, 0x63, 0x70, 0x40, 0xe2, 0x3b, 0x70, 0x42, 0x42, 0x42, 0x3d, 0x56, 0xe2, 0x42,
	0xd3, 0x0b, 0xc7, 0x7e, 0x04, 0xe4, 0xf1, 0xcc, 0x78, 0xc6, 0x76, 0xd2, 0xa4, 0x2c, 0x37, 0xe7,
	0x79, 0xf9, 0xcd, 0xf3, 0xf6, 0x7b, 0x66, 0x76, 0xa1, 0xe1, 0x3b, 0x3d, 0x7c, 0x6c, 0xbf, 0xd9,
	0xb5, 0xf1, 0xb1, 0x37, 0xd8, 0x1e, 0x8e, 0xbc, 0xc0, 0x43, 0xc5, 0x48, 0x68, 0xfe, 0xa2, 0x42,
	0xe9, 0x1e, 0x0e, 0xec, 0xae, 0x1d, 0xd8, 0xa8, 0x0e, 0xf9, 0x23, 0xfc, 0x58, 0x53, 0xb7, 0xd4,
	0x66, 0xc5, 0x0a, 0x3f, 0xd1, 0x26, 0x9c, 0x0e, 0xbc, 0xc0, 0xee, 0x77, 0xdc, 0x6f, 0xb1, 0x96,
	0xdb, 0x52, 0x9b, 0x79, 0x2b, 0x16, 0xa0, 0x0b, 0x50, 0x75, 0x46, 0xd8, 0x0e, 0x5c, 0x6f, 0x70,
	0x73, 0xe8, 0x39, 0x3d, 0x2d, 0x4f, 0x2c, 0x64, 0x21, 0xba, 0x08, 0xb5, 0xbe, 0xed, 0x07, 0x5f,
	0x8c, 0xdc, 0x00, 0x47, 0x66, 0x05, 0x62, 0x96, 0x90, 0xa2, 0xd7, 0xa0, 0xe8, 0xf4, 0xc6, 0x83,
	0x23, 0x5f, 0x5b, 0xda, 0xca, 0x37, 0xcb, 0xad, 0xea, 0x76, 0x14, 0xe3, 0xf6, 0x7e, 0x28, 0xb5,
	0xa8, 0xd2, 0x74, 0x60, 0x89, 0x08, 0xc2, 0xd8, 0x88, 0x88, 0xc4, 0xa6, 0x46, 0xb1, 0x71, 0x01,
	0x6a, 0xc2, 0x29, 0xef, 0xc1, 0x57, 0xd8, 0x09, 0x7c, 0x2d, 0x47, 0xe0, 0x6a, 0x0c, 0xee, 0x90,
	0x88, 0x2d, 0xa6, 0x46, 0x08, 0x0a, 0x3d, 0xdb, 0x8f, 0x82, 0xaf, 0x58, 0xe4, 0xdb, 0xbc, 0x0a,
	0xc5, 0xc8, 0x2c, 0xa3, 0x26, 0x1a, 0x9c, 0xf2, 0x7b, 0xf6, 0xa8, 0x7b, 0xe7, 0x80, 0x54, 0xe4,
	0xb4, 0xc5, 0x7e, 0x9a, 0x57, 0xa1, 0x42, 0xf2, 0xb1, 0xf0, 0xd7, 0x63, 0xec, 0x67, 0xf9, 0x22,
	0x28, 0x84, 0x95, 0x26, 0x8e, 0x15, 0x8b, 0x7c, 0x9b, 0x1f, 0x40, 0x95, 0x7a, 0xf9, 0x43, 0x6f,
	0xe0, 0x63, 0x74, 0x19, 0x4a, 0xc7, 0xb4, 0x25, 0xc4, 0xb7, 0xdc, 0xaa, 0xb3, 0xd8, 0x59, 0xab,
	0x2c, 0x6e, 0x61, 0xde, 0x80, 0x3a, 0x71, 0xbf, 0xe5, 0xf6, 0x67, 0x1c, 0xac, 0x43, 0xe9, 0xa1,
	0xdb, 0xc7, 0x9f, 0xd8, 0x41, 0x8f, 0x46, 0xcd, 0x7f, 0x9b, 0xbb, 0xb0, 0x2c, 0x20, 0xbc, 0x52,
	0x10, 0x7f, 0xaa, 0x80, 0x08, 0x46, 0x27, 0x18, 0x61, 0xfb, 0x98, 0xc5, 0xb1, 0x9b, 0x02, 0xf9,
	0x3f, 0x03, 0x49, 0x5b, 0x73, 0xdc, 0xdb, 0x4a, 0x8c, 0x8c, 0xde, 0x16, 0x2a, 0x56, 0x6e, 0x9d,
	0x9f, 0xe1, 0x7e, 0x10, 0xb9, 0x12, 0x73, 0x7d, 0x73, 0xd6, 0x58, 0xeb, 0x17, 0xa0, 0x10, 0x5a,
	0x87, 0x23, 0x14, 0x5a, 0x90, 0x79, 0xa2, 0x3d, 0x89, 0x05, 0x7b, 0xa7, 0x60, 0xc9, 0x1d, 0x0c,
	0xc7, 0x81, 0xb9, 0x0f, 0x0d, 0xe9, 0xbc, 0x57, 0x2a, 0xd1, 0x97, 0x50, 0xb6, 0xb0, 0xdd, 0x65,
	0xa5, 0x41, 0x42, 0x50, 0xb7, 0x95, 0xa8, 0x49, 0xdb, 0x02, 0x60, 0x2e, 0x1b, 0x50, 0xac, 0x4d,
	0x1c, 0xa0, 0x09, 0x95, 0x08, 0x9b, 0x46, 0xc6, 0xc6, 0x4c, 0x15, 0xc6, 0xec, 0x0f, 0x15, 0xce,
	0x84, 0x46, 0xe2, 0x9c, 0x9c, 0x40, 0x10, 0xd2, 0x64, 0xe5, 0xe5, 0xc9, 0x0a, 0x2b, 0x14, 0x7e,
	0xdf, 0xf3, 0xba, 0x98, 0x90, 0xbe, 0x16, 0x63, 0xdd, 0xa2, 0x72, 0x8b, 0x5b, 0x84, 0xeb, 0xc4,
	0x7f, 0x3c, 0x70, 0x7a, 0x23, 0x6f, 0xe0, 0x8d, 0xfd, 0x3b, 0x87, 0xda, 0xd2, 0x96, 0xda, 0x2c,
	0x59, 0xb2, 0x30, 0x4e, 0x1a, 0x41, 0x3d, 0xce, 0x27, 0x4a, 0xdc, 0xfc, 0x0e, 0x96, 0x43, 0x99,
	0x3c, 0x85, 0x27, 0x91, 0xa5, 0xb4, 0x6c, 0xf2, 0x89, 0x65, 0x13, 0xc7, 0xd4, 0x02, 0x24, 0x9e,
	0x4f, 0xdb, 0x21, 0x8d, 0x99, 0x9a, 0x18, 0x33, 0xf3, 0x3e, 0x54, 0x0f, 0x70, 0x1f, 0x07, 0xf8,
	0x3f, 0x19, 0x8d, 0x3a, 0xd4, 0x18, 0x3a, 0xad, 0x91, 0x07, 0x95, 0xfd, 0x1e, 0x76, 0x8e, 0x4e,
	0xb2, 0x3c, 0x08, 0x0a, 0x0f, 0x6d, 0x3f, 0x20, 0x95, 0x29, 0x59, 0xe4, 0x3b, 0x0e, 0xe1, 0x7d,
	0xa8, 0xd2, 0x03, 0x69, 0x3d, 0xde, 0x80, 0xa2, 0x1f, 0xd8, 0xc1, 0xd8, 0x27, 0x87, 0xd6, 0x5a,
	0x8d, 0x78, 0xd3, 0x63, 0xe7, 0xa8, 0x43, 0x54, 0x16, 0x35, 0x31, 0xff, 0x07, 0x55, 0x0b, 0x0f,
	0x6d, 0x77, 0x34, 0x75, 0xb9, 0x99, 0x3b, 0x50, 0x63, 0x26, 0xaf, 0x44, 0xcd, 0x3d, 0x40, 0x1d,
	0x1c, 0x70, 0x05, 0x3d, 0x67, 0x31, 0x8c, 0x55, 0x68, 0x48, 0x18, 0xb4, 0xd8, 0x17, 0x01, 0xb5,
	0xd3, 0xd0, 0xe9, 0x14, 0xf6, 0xa1, 0xd1, 0x4e, 0xbb, 0x2f, 0x18, 0xc3, 0xeb, 0xb0, 0x1a, 0xf5,
	0xfa, 0xe5, 0xe7, 0x69, 0xb0, 0x96, 0x34, 0xa5, 0x11, 0x6f, 0xc0, 0xfa, 0xc7, 0xae, 0xcf, 0x43,
	0xb9, 0x8b, 0x1f, 0xfb, 0x14, 0xc6, 0xbc, 0x0c, 0x5a, 0x5a, 0x45, 0x23, 0x4d, 0x1f, 0x71, 0x11,
	0xea, 0xe1, 0x92, 0x95, 0x6e, 0xc4, 0xac, 0xc5, 0xf4, 0x1e, 0x2c, 0x0b, 0x76, 0x14, 0x2e, 0x7e,
	0x0c, 0xa8, 0xb3, 0x1e, 0x03, 0x2d, 0x58, 0xe1, 0xbe, 0xe2, 0x62, 0x13, 0x97, 0x92, 0x9a, 0xb8,
	0xee, 0x76, 0x60, 0x35, 0xe1, 0xb3, 0xd8, 0x99, 0xd7, 0x60, 0x8d, 0xfb, 0xcb, 0x8b, 0x66, 0x36,
	0xcf, 0x6f, 0xc0, 0x7a, 0xca, 0x6f, 0xb1, 0x93, 0xdf, 0x81, 0x33, 0x07, 0xa4, 0x55, 0xf1, 0x35,
	0x32, 0xa7, 0x27, 0xed, 0xc5, 0x4b, 0x2f, 0x89, 0x9f, 0x55, 0x68, 0x30, 0x43, 0xb1, 0x9e, 0xf3,
	0x1d, 0x33, 0xeb, 0x95, 0x21, 0xdd, 0x05, 0xf9, 0xc5, 0xef, 0x82, 0x42, 0xc6, 0x5d, 0x60, 0xae,
	0x45, 0xed, 0x4f, 0x5d, 0x03, 0xf7, 0xa3, 0x16, 0xa7, 0xaf, 0x82, 0x39, 0xf3, 0x90, 0xb6, 0x7d,
	0x2e, 0xb1, 0xed, 0xd9, 0x00, 0x2c, 0xbc, 0xe8, 0xe9, 0xa0, 0xcb, 0xcb, 0x7e, 0xce, 0x06, 0xae,
	0x00, 0x12, 0x7d, 0x69, 0x9e, 0xf7, 0xa2, 0xb6, 0x4a, 0xeb, 0x7c, 0xce, 0x14, 0xd9, 0xc6, 0xce,
	0xc5, 0x1b, 0xdb, 0xbc, 0x11, 0x05, 0xf8, 0x2f, 0x96, 0x35, 0x4d, 0x51, 0x5e, 0xd8, 0x73, 0xa6,
	0x78, 0x3d, 0x4a, 0x31, 0xb1, 0xc9, 0xe7, 0x73, 0xbe, 0xd4, 0x81, 0xb2, 0x10, 0x0f, 0x5a, 0x03,
	0x24, 0xfc, 0xbc, 0x33, 0x78, 0x64, 0xf7, 0xdd, 0x6e, 0x5d, 0x41, 0x2b, 0x50, 0x17, 0xe4, 0x9f,
	0x13, 0xa9, 0x9a, 0xb0, 0x3e, 0x1c, 0x06, 0xee, 0xb1, 0xdd, 0xaf, 0xe7, 0x2e, 0xdd, 0x85, 0x12,
	0x1b, 0xcd, 0xd0, 0x93, 0x7d, 0x7f, 0x36, 0x1a, 0x0f, 0x1c, 0x3b, 0xc0, 0x75, 0x05, 0x21, 0xa8,
	0x31, 0xe9, 0xee, 0x70, 0x88, 0x07, 0x21, 0xda, 0x2a, 0x2c, 0x33, 0xd9, 0xcd, 0x6f, 0x9c, 0xfe,
	0xd8, 0x77, 0x1f, 0xe1, 0x7a, 0xae, 0xf5, 0x6b, 0x01, 0xca, 0xa1, 0xbc, 0x83, 0x47, 0x8f, 0x5c,
	0x07, 0xa3, 0x6b, 0xb0, 0x44, 0x56, 0x01, 0x5a, 0x91, 0xde, 0xb4, 0xb4, 0x68, 0xfa, 0x6a, 0x42,
	0x4a, 0x3b, 0xae, 0xa0, 0x3d, 0x38, 0xcd, 0x57, 0x17, 0xd2, 0x24, 0x2b, 0x81, 0xb1, 0xfa, 0x46,
	0x86, 0x86, 0x63, 0x7c, 0x04, 0x65, 0x61, 0x0d, 0x21, 0x7d, 0xfa, 0xab, 0x5a, 0x3f, 0x9b, 0xa9,
	0x63, 0x48, 0x4d, 0x15, 0x5d, 0x81, 0x42, 0xc8, 0x04, 0xc4, 0xe7, 0x42, 0x58, 0x4f, 0xfa, 0x8a,
	0x2c, 0xe4, 0x01, 0x7c, 0x08, 0x25, 0x46, 0x5a, 0xb4, 0x2e, 0xda, 0x88, 0x29, 0x68, 0x69, 0x05,
	0x07, 0x68, 0x03, 0xc4, 0xfc, 0x43, 0x1b, 0xa2, 0xa5, 0x1c, 0xbf, 0x9e, 0xa5, 0x62, 0x30, 0x6f,
	0xa9, 0xe8, 0x5d, 0x28, 0x46, 0xa4, 0x42, 0xbc, 0xe2, 0x12, 0x41, 0xf5, 0xb5, 0xa4, 0x98, 0xc7,
	0x70, 0x2d, 0xfc, 0x4b, 0x14, 0x3b, 0x47, 0x71, 0x07, 0x45, 0x22, 0xc6, 0x1d, 0x94, 0xf8, 0x64,
	0x2a, 0xe1, 0x91, 0xd1, 0x90, 0xc7, 0x47, 0x4a, 0x84, 0x89, 0x8f, 0x94, 0xb9, 0x60, 0x2a, 0xad,
	0xdf, 0x73, 0x70, 0x86, 0x5d, 0xbf, 0x6c, 0x90, 0x6e, 0x43, 0x59, 0x78, 0x79, 0xc4, 0xcd, 0x4c,
	0x3f, 0x69, 0xe2, 0x66, 0x66, 0x3d, 0x55, 0x94, 0x10, 0xa9, 0x9d, 0x85, 0xd4, 0x9e, 0x81, 0xd4,
	0xce, 0x44, 0xfa, 0x94, 0xbd, 0x3a, 0x39, 0xd8, 0x39, 0xb9, 0x8c, 0x49, 0x3c, 0x63, 0x9a, 0x5a,
	0x80, 0x2c, 0x85, 0x8f, 0x8f, 0xf0, 0xd1, 0x81, 0xf8, 0x9f, 0x81, 0x53, 0x5e, 0x2a, 0xfa, 0xd6,
	0x74, 0x83, 0xb8, 0xf7, 0xad, 0x1f, 0x96, 0xa0, 0x7c, 0x20, 0x54, 0x72, 0x87, 0x51, 0x92, 0x4f,
	0x5e, 0xf2, 0x01, 0x13, 0xd3, 0x2a, 0xf5, 0x64, 0x21, 0xb4, 0x12, 0xa8, 0xb9, 0x99, 0xb2, 0x14,
	0x67, 0xfb, 0xdc, 0x14, 0x2d, 0xc7, 0xb2, 0x64, 0x8a, 0x1a, 0x29, 0x7b, 0x79, 0xcc, 0xcf, 0x4f,
	0xd5, 0x0b, 0x54, 0xbd, 0x4e, 0xa9, 0xba, 0x2e, 0x1a, 0x8b, 0x74, 0xd5, 0xd2, 0x0a, 0x81, 0x71,
	0x31, 0x65, 0xcf, 0x26, 0xed, 0xc4, 0xd4, 0x36, 0xb3, 0x95, 0x1c, 0xe8, 0x50, 0xa2, 0xee, 0xb9,
	0xa4, 0xb5, 0x9c, 0x97, 0x31, 0x4d, 0x2d, 0x50, 0x78, 0x97, 0x53, 0x58, 0xea, 0x8e, 0x4c, 0x63,
	0x3d, 0x4b, 0xc5, 0x63, 0xda, 0x61, 0x54, 0x96, 0x2a, 0x20, 0xd1, 0x79, 0x23, 0x43, 0xc3, 0xfd,
	0x77, 0x39, 0xa5, 0x37, 0xe4, 0x80, 0x45, 0x5a, 0xeb, 0x59, 0x2a, 0x06, 0xb1, 0x77, 0xf5, 0xc9,
	0x33, 0x43, 0x79, 0xfa, 0xcc, 0x50, 0x5e, 0x3c, 0x33, 0xd4, 0xef, 0x27, 0x86, 0xfa, 0xd3, 0xc4,
	0x50, 0x7f, 0x9b, 0x18, 0xea, 0x93, 0x89, 0xa1, 0xfe, 0x35, 0x31, 0xd4, 0xbf, 0x27, 0x86, 0xf2,
	0x62, 0x62, 0xa8, 0x3f, 0x3e, 0x37, 0x94, 0x27, 0xcf, 0x0d, 0xe5, 0xe9, 0x73, 0x43, 0x79, 0x50,
	0x24, 0xff, 0xce, 0xbb, 0xf2, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x30, 0x05, 0xf6, 0xdd, 0xe5,
	0x13, 0x00, 0x00,
}

func (x CheckStatus) String() string {
	s, ok := CheckStatus_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FileMode) String() string {
	s, ok := FileMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Metadata)
	if !ok {
		that2, ok := that.(Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.TotalSize != that1.TotalSize {
		return false
	}
	if this.CreationEpoch != that1.CreationEpoch {
		return false
	}
	if this.LastWriteEpoch != that1.LastWriteEpoch {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *Chunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Chunk)
	if !ok {
		that2, ok := that.(Chunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	if len(this.Objects) != len(that1.Objects) {
		return false
	}
	for i := range this.Objects {
		if !this.Objects[i].Equal(that1.Objects[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	return true
}
func (this *Object) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Object)
	if !ok {
		that2, ok := that.(Object)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.ShardID != that1.ShardID {
		return false
	}
	return true
}
func (this *WriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteRequest)
	if !ok {
		that2, ok := that.(WriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *WriteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteResponse)
	if !ok {
		that2, ok := that.(WriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *WriteFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteFileRequest)
	if !ok {
		that2, ok := that.(WriteFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	return true
}
func (this *WriteFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteFileResponse)
	if !ok {
		that2, ok := that.(WriteFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *WriteStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest)
	if !ok {
		that2, ok := that.(WriteStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Metadata_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Metadata_)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Metadata_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Data_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Data_)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Data_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Metadata)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *WriteStreamRequest_Data) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamRequest_Data)
	if !ok {
		that2, ok := that.(WriteStreamRequest_Data)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *WriteStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteStreamResponse)
	if !ok {
		that2, ok := that.(WriteStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	return true
}
func (this *ReadRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest_Key)
	if !ok {
		that2, ok := that.(ReadRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest_Metadata)
	if !ok {
		that2, ok := that.(ReadRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadResponse)
	if !ok {
		that2, ok := that.(ReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *ReadFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest)
	if !ok {
		that2, ok := that.(ReadFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.SynchronousIO != that1.SynchronousIO {
		return false
	}
	return true
}
func (this *ReadFileRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest_Key)
	if !ok {
		that2, ok := that.(ReadFileRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadFileRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileRequest_Metadata)
	if !ok {
		that2, ok := that.(ReadFileRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadFileResponse)
	if !ok {
		that2, ok := that.(ReadFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ReadStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest)
	if !ok {
		that2, ok := that.(ReadStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	return true
}
func (this *ReadStreamRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest_Key)
	if !ok {
		that2, ok := that.(ReadStreamRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *ReadStreamRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamRequest_Metadata)
	if !ok {
		that2, ok := that.(ReadStreamRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ReadStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadStreamResponse)
	if !ok {
		that2, ok := that.(ReadStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *DeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest)
	if !ok {
		that2, ok := that.(DeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	return true
}
func (this *DeleteRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest_Key)
	if !ok {
		that2, ok := that.(DeleteRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *DeleteRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRequest_Metadata)
	if !ok {
		that2, ok := that.(DeleteRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *DeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteResponse)
	if !ok {
		that2, ok := that.(DeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest)
	if !ok {
		that2, ok := that.(CheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Input == nil {
		if this.Input != nil {
			return false
		}
	} else if this.Input == nil {
		return false
	} else if !this.Input.Equal(that1.Input) {
		return false
	}
	if this.Fast != that1.Fast {
		return false
	}
	return true
}
func (this *CheckRequest_Key) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest_Key)
	if !ok {
		that2, ok := that.(CheckRequest_Key)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *CheckRequest_Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckRequest_Metadata)
	if !ok {
		that2, ok := that.(CheckRequest_Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *CheckResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckResponse)
	if !ok {
		that2, ok := that.(CheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *RepairRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepairRequest)
	if !ok {
		that2, ok := that.(RepairRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *RepairResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RepairResponse)
	if !ok {
		that2, ok := that.(RepairResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *SetMetadataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetMetadataRequest)
	if !ok {
		that2, ok := that.(SetMetadataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *SetMetadataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SetMetadataResponse)
	if !ok {
		that2, ok := that.(SetMetadataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetMetadataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetMetadataRequest)
	if !ok {
		that2, ok := that.(GetMetadataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *GetMetadataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetMetadataResponse)
	if !ok {
		that2, ok := that.(GetMetadataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *DeleteMetadataRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteMetadataRequest)
	if !ok {
		that2, ok := that.(DeleteMetadataRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *DeleteMetadataResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteMetadataResponse)
	if !ok {
		that2, ok := that.(DeleteMetadataResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ListMetadataKeysRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetadataKeysRequest)
	if !ok {
		that2, ok := that.(ListMetadataKeysRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ListMetadataKeysResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetadataKeysResponse)
	if !ok {
		that2, ok := that.(ListMetadataKeysResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	return true
}
func (this *DataWriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteRequest)
	if !ok {
		that2, ok := that.(DataWriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *DataWriteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteResponse)
	if !ok {
		that2, ok := that.(DataWriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataWriteFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteFileRequest)
	if !ok {
		that2, ok := that.(DataWriteFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	return true
}
func (this *DataWriteFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteFileResponse)
	if !ok {
		that2, ok := that.(DataWriteFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataWriteStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteStreamRequest)
	if !ok {
		that2, ok := that.(DataWriteStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *DataWriteStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataWriteStreamResponse)
	if !ok {
		that2, ok := that.(DataWriteStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadRequest)
	if !ok {
		that2, ok := that.(DataReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadResponse)
	if !ok {
		that2, ok := that.(DataReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *DataReadFileRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadFileRequest)
	if !ok {
		that2, ok := that.(DataReadFileRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if this.FileMode != that1.FileMode {
		return false
	}
	if this.SynchronousIO != that1.SynchronousIO {
		return false
	}
	return true
}
func (this *DataReadFileResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadFileResponse)
	if !ok {
		that2, ok := that.(DataReadFileResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DataReadStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadStreamRequest)
	if !ok {
		that2, ok := that.(DataReadStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if this.ChunkSize != that1.ChunkSize {
		return false
	}
	return true
}
func (this *DataReadStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataReadStreamResponse)
	if !ok {
		that2, ok := that.(DataReadStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DataChunk, that1.DataChunk) {
		return false
	}
	return true
}
func (this *DataDeleteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataDeleteRequest)
	if !ok {
		that2, ok := that.(DataDeleteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataDeleteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataDeleteResponse)
	if !ok {
		that2, ok := that.(DataDeleteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DataCheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataCheckRequest)
	if !ok {
		that2, ok := that.(DataCheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	if this.Fast != that1.Fast {
		return false
	}
	return true
}
func (this *DataCheckResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataCheckResponse)
	if !ok {
		that2, ok := that.(DataCheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *DataRepairRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataRepairRequest)
	if !ok {
		that2, ok := that.(DataRepairRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *DataRepairResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataRepairResponse)
	if !ok {
		that2, ok := that.(DataRepairResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.Metadata{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "TotalSize: "+fmt.Sprintf("%#v", this.TotalSize)+",\n")
	s = append(s, "CreationEpoch: "+fmt.Sprintf("%#v", this.CreationEpoch)+",\n")
	s = append(s, "LastWriteEpoch: "+fmt.Sprintf("%#v", this.LastWriteEpoch)+",\n")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Chunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.Chunk{")
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	if this.Objects != nil {
		s = append(s, "Objects: "+fmt.Sprintf("%#v", this.Objects)+",\n")
	}
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Object) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Object{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "ShardID: "+fmt.Sprintf("%#v", this.ShardID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WriteRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WriteFileRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteFileResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.WriteStreamRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest_Metadata_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WriteStreamRequest_Metadata_{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *WriteStreamRequest_Data_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WriteStreamRequest_Data_{` +
		`Data:` + fmt.Sprintf("%#v", this.Data) + `}`}, ", ")
	return s
}
func (this *WriteStreamRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteStreamRequest_Metadata{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamRequest_Data) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteStreamRequest_Data{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WriteStreamResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ReadRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *ReadRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *ReadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ReadResponse{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.ReadFileRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "FileMode: "+fmt.Sprintf("%#v", this.FileMode)+",\n")
	s = append(s, "SynchronousIO: "+fmt.Sprintf("%#v", this.SynchronousIO)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadFileRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadFileRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *ReadFileRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadFileRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *ReadFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.ReadFileResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.ReadStreamRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadStreamRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadStreamRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *ReadStreamRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ReadStreamRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *ReadStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ReadStreamResponse{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DeleteRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DeleteRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *DeleteRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DeleteRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *DeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DeleteResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.CheckRequest{")
	if this.Input != nil {
		s = append(s, "Input: "+fmt.Sprintf("%#v", this.Input)+",\n")
	}
	s = append(s, "Fast: "+fmt.Sprintf("%#v", this.Fast)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckRequest_Key) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CheckRequest_Key{` +
		`Key:` + fmt.Sprintf("%#v", this.Key) + `}`}, ", ")
	return s
}
func (this *CheckRequest_Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CheckRequest_Metadata{` +
		`Metadata:` + fmt.Sprintf("%#v", this.Metadata) + `}`}, ", ")
	return s
}
func (this *CheckResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.CheckResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepairRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.RepairRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RepairResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.RepairResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetMetadataRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.SetMetadataRequest{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetMetadataResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.SetMetadataResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetMetadataRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.GetMetadataRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetMetadataResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.GetMetadataResponse{")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMetadataRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DeleteMetadataRequest{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMetadataResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DeleteMetadataResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetadataKeysRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.ListMetadataKeysRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetadataKeysResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ListMetadataKeysResponse{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteRequest{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteFileRequest{")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteFileResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteStreamRequest{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataWriteStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataWriteStreamResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataReadRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataReadResponse{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadFileRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.DataReadFileRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "FileMode: "+fmt.Sprintf("%#v", this.FileMode)+",\n")
	s = append(s, "SynchronousIO: "+fmt.Sprintf("%#v", this.SynchronousIO)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadFileResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DataReadFileResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DataReadStreamRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "ChunkSize: "+fmt.Sprintf("%#v", this.ChunkSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataReadStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataReadStreamResponse{")
	s = append(s, "DataChunk: "+fmt.Sprintf("%#v", this.DataChunk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataDeleteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataDeleteRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataDeleteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.DataDeleteResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataCheckRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DataCheckRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "Fast: "+fmt.Sprintf("%#v", this.Fast)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataCheckResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataCheckResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataRepairRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataRepairRequest{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataRepairResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DataRepairResponse{")
	if this.Chunks != nil {
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", this.Chunks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDaemon(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileServiceClient interface {
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error)
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (FileService_WriteStreamClient, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error)
	ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (FileService_ReadStreamClient, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	Check(ctx context.Context, in *CheckRequest, opts ...grpc.CallOption) (*CheckResponse, error)
	Repair(ctx context.Context, in *RepairRequest, opts ...grpc.CallOption) (*RepairResponse, error)
}

type fileServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileServiceClient(cc *grpc.ClientConn) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/Write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpc.CallOption) (*WriteFileResponse, error) {
	out := new(WriteFileResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/WriteFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (FileService_WriteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileService_serviceDesc.Streams[0], "/schema.FileService/WriteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceWriteStreamClient{stream}
	return x, nil
}

type FileService_WriteStreamClient interface {
	Send(*WriteStreamRequest) error
	CloseAndRecv() (*WriteStreamResponse, error)
	grpc.ClientStream
}

type fileServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *fileServiceWriteStreamClient) Send(m *WriteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileServiceWriteStreamClient) CloseAndRecv() (*WriteStreamResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpc.CallOption) (*ReadFileResponse, error) {
	out := new(ReadFileResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/ReadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (FileService_ReadStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FileService_serviceDesc.Streams[1], "/schema.FileService/ReadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileService_ReadStreamClient interface {
	Recv() (*ReadStreamResponse, error)
	grpc.ClientStream
}

type fileServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *fileServiceReadStreamClient) Recv() (*ReadStreamResponse, error) {
	m := new(ReadStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Check(ctx context.Context, in *CheckRequest, opts ...grpc.CallOption) (*CheckResponse, error) {
	out := new(CheckResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) Repair(ctx context.Context, in *RepairRequest, opts ...grpc.CallOption) (*RepairResponse, error) {
	out := new(RepairResponse)
	err := c.cc.Invoke(ctx, "/schema.FileService/Repair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileServiceServer is the server API for FileService service.
type FileServiceServer interface {
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	WriteFile(context.Context, *WriteFileRequest) (*WriteFileResponse, error)
	WriteStream(FileService_WriteStreamServer) error
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	ReadFile(context.Context, *ReadFileRequest) (*ReadFileResponse, error)
	ReadStream(*ReadStreamRequest, FileService_ReadStreamServer) error
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	Check(context.Context, *CheckRequest) (*CheckResponse, error)
	Repair(context.Context, *RepairRequest) (*RepairResponse, error)
}

// UnimplementedFileServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFileServiceServer struct {
}

func (*UnimplementedFileServiceServer) Write(ctx context.Context, req *WriteRequest) (*WriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (*UnimplementedFileServiceServer) WriteFile(ctx context.Context, req *WriteFileRequest) (*WriteFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteFile not implemented")
}
func (*UnimplementedFileServiceServer) WriteStream(srv FileService_WriteStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteStream not implemented")
}
func (*UnimplementedFileServiceServer) Read(ctx context.Context, req *ReadRequest) (*ReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedFileServiceServer) ReadFile(ctx context.Context, req *ReadFileRequest) (*ReadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFile not implemented")
}
func (*UnimplementedFileServiceServer) ReadStream(req *ReadStreamRequest, srv FileService_ReadStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadStream not implemented")
}
func (*UnimplementedFileServiceServer) Delete(ctx context.Context, req *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedFileServiceServer) Check(ctx context.Context, req *CheckRequest) (*CheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (*UnimplementedFileServiceServer) Repair(ctx context.Context, req *RepairRequest) (*RepairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Repair not implemented")
}

func RegisterFileServiceServer(s *grpc.Server, srv FileServiceServer) {
	s.RegisterService(&_FileService_serviceDesc, srv)
}

func _FileService_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/WriteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).WriteFile(ctx, req.(*WriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileServiceServer).WriteStream(&fileServiceWriteStreamServer{stream})
}

type FileService_WriteStreamServer interface {
	SendAndClose(*WriteStreamResponse) error
	Recv() (*WriteStreamRequest, error)
	grpc.ServerStream
}

type fileServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *fileServiceWriteStreamServer) SendAndClose(m *WriteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileServiceWriteStreamServer) Recv() (*WriteStreamRequest, error) {
	m := new(WriteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/ReadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).ReadFile(ctx, req.(*ReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileServiceServer).ReadStream(m, &fileServiceReadStreamServer{stream})
}

type FileService_ReadStreamServer interface {
	Send(*ReadStreamResponse) error
	grpc.ServerStream
}

type fileServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *fileServiceReadStreamServer) Send(m *ReadStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _FileService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Check(ctx, req.(*CheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_Repair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).Repair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.FileService/Repair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).Repair(ctx, req.(*RepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schema.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _FileService_Write_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _FileService_WriteFile_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _FileService_Read_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _FileService_ReadFile_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FileService_Delete_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _FileService_Check_Handler,
		},
		{
			MethodName: "Repair",
			Handler:    _FileService_Repair_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteStream",
			Handler:       _FileService_WriteStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadStream",
			Handler:       _FileService_ReadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

// MetadataServiceClient is the client API for MetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetadataServiceClient interface {
	SetMetadata(ctx context.Context, in *SetMetadataRequest, opts ...grpc.CallOption) (*SetMetadataResponse, error)
	GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error)
	DeleteMetadata(ctx context.Context, in *DeleteMetadataRequest, opts ...grpc.CallOption) (*DeleteMetadataResponse, error)
	ListKeys(ctx context.Context, in *ListMetadataKeysRequest, opts ...grpc.CallOption) (MetadataService_ListKeysClient, error)
}

type metadataServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetadataServiceClient(cc *grpc.ClientConn) MetadataServiceClient {
	return &metadataServiceClient{cc}
}

func (c *metadataServiceClient) SetMetadata(ctx context.Context, in *SetMetadataRequest, opts ...grpc.CallOption) (*SetMetadataResponse, error) {
	out := new(SetMetadataResponse)
	err := c.cc.Invoke(ctx, "/schema.MetadataService/SetMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error) {
	out := new(GetMetadataResponse)
	err := c.cc.Invoke(ctx, "/schema.MetadataService/GetMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) DeleteMetadata(ctx context.Context, in *DeleteMetadataRequest, opts ...grpc.CallOption) (*DeleteMetadataResponse, error) {
	out := new(DeleteMetadataResponse)
	err := c.cc.Invoke(ctx, "/schema.MetadataService/DeleteMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataServiceClient) ListKeys(ctx context.Context, in *ListMetadataKeysRequest, opts ...grpc.CallOption) (MetadataService_ListKeysClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MetadataService_serviceDesc.Streams[0], "/schema.MetadataService/ListKeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &metadataServiceListKeysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MetadataService_ListKeysClient interface {
	Recv() (*ListMetadataKeysResponse, error)
	grpc.ClientStream
}

type metadataServiceListKeysClient struct {
	grpc.ClientStream
}

func (x *metadataServiceListKeysClient) Recv() (*ListMetadataKeysResponse, error) {
	m := new(ListMetadataKeysResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MetadataServiceServer is the server API for MetadataService service.
type MetadataServiceServer interface {
	SetMetadata(context.Context, *SetMetadataRequest) (*SetMetadataResponse, error)
	GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataResponse, error)
	DeleteMetadata(context.Context, *DeleteMetadataRequest) (*DeleteMetadataResponse, error)
	ListKeys(*ListMetadataKeysRequest, MetadataService_ListKeysServer) error
}

// UnimplementedMetadataServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMetadataServiceServer struct {
}

func (*UnimplementedMetadataServiceServer) SetMetadata(ctx context.Context, req *SetMetadataRequest) (*SetMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMetadata not implemented")
}
func (*UnimplementedMetadataServiceServer) GetMetadata(ctx context.Context, req *GetMetadataRequest) (*GetMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadata not implemented")
}
func (*UnimplementedMetadataServiceServer) DeleteMetadata(ctx context.Context, req *DeleteMetadataRequest) (*DeleteMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMetadata not implemented")
}
func (*UnimplementedMetadataServiceServer) ListKeys(req *ListMetadataKeysRequest, srv MetadataService_ListKeysServer) error {
	return status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}

func RegisterMetadataServiceServer(s *grpc.Server, srv MetadataServiceServer) {
	s.RegisterService(&_MetadataService_serviceDesc, srv)
}

func _MetadataService_SetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).SetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.MetadataService/SetMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).SetMetadata(ctx, req.(*SetMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_GetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).GetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.MetadataService/GetMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).GetMetadata(ctx, req.(*GetMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_DeleteMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataServiceServer).DeleteMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.MetadataService/DeleteMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataServiceServer).DeleteMetadata(ctx, req.(*DeleteMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataService_ListKeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListMetadataKeysRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MetadataServiceServer).ListKeys(m, &metadataServiceListKeysServer{stream})
}

type MetadataService_ListKeysServer interface {
	Send(*ListMetadataKeysResponse) error
	grpc.ServerStream
}

type metadataServiceListKeysServer struct {
	grpc.ServerStream
}

func (x *metadataServiceListKeysServer) Send(m *ListMetadataKeysResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _MetadataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schema.MetadataService",
	HandlerType: (*MetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetMetadata",
			Handler:    _MetadataService_SetMetadata_Handler,
		},
		{
			MethodName: "GetMetadata",
			Handler:    _MetadataService_GetMetadata_Handler,
		},
		{
			MethodName: "DeleteMetadata",
			Handler:    _MetadataService_DeleteMetadata_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListKeys",
			Handler:       _MetadataService_ListKeys_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

// DataServiceClient is the client API for DataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataServiceClient interface {
	Write(ctx context.Context, in *DataWriteRequest, opts ...grpc.CallOption) (*DataWriteResponse, error)
	WriteFile(ctx context.Context, in *DataWriteFileRequest, opts ...grpc.CallOption) (*DataWriteFileResponse, error)
	WriteStream(ctx context.Context, opts ...grpc.CallOption) (DataService_WriteStreamClient, error)
	Read(ctx context.Context, in *DataReadRequest, opts ...grpc.CallOption) (*DataReadResponse, error)
	ReadFile(ctx context.Context, in *DataReadFileRequest, opts ...grpc.CallOption) (*DataReadFileResponse, error)
	ReadStream(ctx context.Context, in *DataReadStreamRequest, opts ...grpc.CallOption) (DataService_ReadStreamClient, error)
	Delete(ctx context.Context, in *DataDeleteRequest, opts ...grpc.CallOption) (*DataDeleteResponse, error)
	Check(ctx context.Context, in *DataCheckRequest, opts ...grpc.CallOption) (*DataCheckResponse, error)
	Repair(ctx context.Context, in *DataRepairRequest, opts ...grpc.CallOption) (*DataRepairResponse, error)
}

type dataServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataServiceClient(cc *grpc.ClientConn) DataServiceClient {
	return &dataServiceClient{cc}
}

func (c *dataServiceClient) Write(ctx context.Context, in *DataWriteRequest, opts ...grpc.CallOption) (*DataWriteResponse, error) {
	out := new(DataWriteResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/Write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) WriteFile(ctx context.Context, in *DataWriteFileRequest, opts ...grpc.CallOption) (*DataWriteFileResponse, error) {
	out := new(DataWriteFileResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/WriteFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) WriteStream(ctx context.Context, opts ...grpc.CallOption) (DataService_WriteStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataService_serviceDesc.Streams[0], "/schema.DataService/WriteStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceWriteStreamClient{stream}
	return x, nil
}

type DataService_WriteStreamClient interface {
	Send(*DataWriteStreamRequest) error
	CloseAndRecv() (*DataWriteStreamResponse, error)
	grpc.ClientStream
}

type dataServiceWriteStreamClient struct {
	grpc.ClientStream
}

func (x *dataServiceWriteStreamClient) Send(m *DataWriteStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataServiceWriteStreamClient) CloseAndRecv() (*DataWriteStreamResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DataWriteStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) Read(ctx context.Context, in *DataReadRequest, opts ...grpc.CallOption) (*DataReadResponse, error) {
	out := new(DataReadResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ReadFile(ctx context.Context, in *DataReadFileRequest, opts ...grpc.CallOption) (*DataReadFileResponse, error) {
	out := new(DataReadFileResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/ReadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ReadStream(ctx context.Context, in *DataReadStreamRequest, opts ...grpc.CallOption) (DataService_ReadStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataService_serviceDesc.Streams[1], "/schema.DataService/ReadStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceReadStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_ReadStreamClient interface {
	Recv() (*DataReadStreamResponse, error)
	grpc.ClientStream
}

type dataServiceReadStreamClient struct {
	grpc.ClientStream
}

func (x *dataServiceReadStreamClient) Recv() (*DataReadStreamResponse, error) {
	m := new(DataReadStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) Delete(ctx context.Context, in *DataDeleteRequest, opts ...grpc.CallOption) (*DataDeleteResponse, error) {
	out := new(DataDeleteResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) Check(ctx context.Context, in *DataCheckRequest, opts ...grpc.CallOption) (*DataCheckResponse, error) {
	out := new(DataCheckResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/Check", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) Repair(ctx context.Context, in *DataRepairRequest, opts ...grpc.CallOption) (*DataRepairResponse, error) {
	out := new(DataRepairResponse)
	err := c.cc.Invoke(ctx, "/schema.DataService/Repair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataServiceServer is the server API for DataService service.
type DataServiceServer interface {
	Write(context.Context, *DataWriteRequest) (*DataWriteResponse, error)
	WriteFile(context.Context, *DataWriteFileRequest) (*DataWriteFileResponse, error)
	WriteStream(DataService_WriteStreamServer) error
	Read(context.Context, *DataReadRequest) (*DataReadResponse, error)
	ReadFile(context.Context, *DataReadFileRequest) (*DataReadFileResponse, error)
	ReadStream(*DataReadStreamRequest, DataService_ReadStreamServer) error
	Delete(context.Context, *DataDeleteRequest) (*DataDeleteResponse, error)
	Check(context.Context, *DataCheckRequest) (*DataCheckResponse, error)
	Repair(context.Context, *DataRepairRequest) (*DataRepairResponse, error)
}

// UnimplementedDataServiceServer can be embedded to have forward compatible implementations.
type UnimplementedDataServiceServer struct {
}

func (*UnimplementedDataServiceServer) Write(ctx context.Context, req *DataWriteRequest) (*DataWriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (*UnimplementedDataServiceServer) WriteFile(ctx context.Context, req *DataWriteFileRequest) (*DataWriteFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteFile not implemented")
}
func (*UnimplementedDataServiceServer) WriteStream(srv DataService_WriteStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteStream not implemented")
}
func (*UnimplementedDataServiceServer) Read(ctx context.Context, req *DataReadRequest) (*DataReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedDataServiceServer) ReadFile(ctx context.Context, req *DataReadFileRequest) (*DataReadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadFile not implemented")
}
func (*UnimplementedDataServiceServer) ReadStream(req *DataReadStreamRequest, srv DataService_ReadStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadStream not implemented")
}
func (*UnimplementedDataServiceServer) Delete(ctx context.Context, req *DataDeleteRequest) (*DataDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedDataServiceServer) Check(ctx context.Context, req *DataCheckRequest) (*DataCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}
func (*UnimplementedDataServiceServer) Repair(ctx context.Context, req *DataRepairRequest) (*DataRepairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Repair not implemented")
}

func RegisterDataServiceServer(s *grpc.Server, srv DataServiceServer) {
	s.RegisterService(&_DataService_serviceDesc, srv)
}

func _DataService_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataWriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Write(ctx, req.(*DataWriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_WriteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataWriteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).WriteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/WriteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).WriteFile(ctx, req.(*DataWriteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_WriteStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataServiceServer).WriteStream(&dataServiceWriteStreamServer{stream})
}

type DataService_WriteStreamServer interface {
	SendAndClose(*DataWriteStreamResponse) error
	Recv() (*DataWriteStreamRequest, error)
	grpc.ServerStream
}

type dataServiceWriteStreamServer struct {
	grpc.ServerStream
}

func (x *dataServiceWriteStreamServer) SendAndClose(m *DataWriteStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataServiceWriteStreamServer) Recv() (*DataWriteStreamRequest, error) {
	m := new(DataWriteStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Read(ctx, req.(*DataReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ReadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataReadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ReadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/ReadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ReadFile(ctx, req.(*DataReadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ReadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DataReadStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).ReadStream(m, &dataServiceReadStreamServer{stream})
}

type DataService_ReadStreamServer interface {
	Send(*DataReadStreamResponse) error
	grpc.ServerStream
}

type dataServiceReadStreamServer struct {
	grpc.ServerStream
}

func (x *dataServiceReadStreamServer) Send(m *DataReadStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Delete(ctx, req.(*DataDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Check(ctx, req.(*DataCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_Repair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataRepairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).Repair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schema.DataService/Repair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).Repair(ctx, req.(*DataRepairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schema.DataService",
	HandlerType: (*DataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _DataService_Write_Handler,
		},
		{
			MethodName: "WriteFile",
			Handler:    _DataService_WriteFile_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _DataService_Read_Handler,
		},
		{
			MethodName: "ReadFile",
			Handler:    _DataService_ReadFile_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DataService_Delete_Handler,
		},
		{
			MethodName: "Check",
			Handler:    _DataService_Check_Handler,
		},
		{
			MethodName: "Repair",
			Handler:    _DataService_Repair_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteStream",
			Handler:       _DataService_WriteStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ReadStream",
			Handler:       _DataService_ReadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "schema/daemon.proto",
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastWriteEpoch != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.LastWriteEpoch))
		i--
		dAtA[i] = 0x20
	}
	if m.CreationEpoch != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.CreationEpoch))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalSize != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chunk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ChunkSize != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.ChunkSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShardID) > 0 {
		i -= len(m.ShardID)
		copy(dAtA[i:], m.ShardID)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.ShardID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WriteStreamRequest_Metadata_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteStreamRequest_Metadata_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WriteStreamRequest_Data_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteStreamRequest_Data_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WriteStreamRequest_Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteStreamRequest_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteStreamRequest_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamRequest_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteStreamRequest_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		i -= len(m.DataChunk)
		copy(dAtA[i:], m.DataChunk)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *WriteStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SynchronousIO {
		i--
		if m.SynchronousIO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.FileMode != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.FileMode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadFileRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadFileRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadFileRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadFileRequest_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ReadStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChunkSize != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.ChunkSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReadStreamRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadStreamRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReadStreamRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadStreamRequest_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReadStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		i -= len(m.DataChunk)
		copy(dAtA[i:], m.DataChunk)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DeleteRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRequest_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fast {
		i--
		if m.Fast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Input != nil {
		{
			size := m.Input.Size()
			i -= size
			if _, err := m.Input.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CheckRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CheckRequest_Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckRequest_Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDaemon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListMetadataKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetadataKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMetadataKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListMetadataKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetadataKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMetadataKeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataWriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataWriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataWriteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataWriteFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataWriteFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataWriteFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataWriteStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataWriteStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		i -= len(m.DataChunk)
		copy(dAtA[i:], m.DataChunk)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataWriteStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataWriteStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataWriteStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataReadFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReadFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SynchronousIO {
		i--
		if m.SynchronousIO {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.FileMode != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.FileMode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataReadFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReadFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DataReadStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReadStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChunkSize != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.ChunkSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataReadStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReadStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReadStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataChunk) > 0 {
		i -= len(m.DataChunk)
		copy(dAtA[i:], m.DataChunk)
		i = encodeVarintDaemon(dAtA, i, uint64(len(m.DataChunk)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DataCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fast {
		i--
		if m.Fast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintDaemon(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataRepairRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRepairRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRepairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataRepairResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataRepairResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataRepairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for iNdEx := len(m.Chunks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chunks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDaemon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDaemon(dAtA []byte, offset int, v uint64) int {
	offset -= sovDaemon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovDaemon(uint64(m.TotalSize))
	}
	if m.CreationEpoch != 0 {
		n += 1 + sovDaemon(uint64(m.CreationEpoch))
	}
	if m.LastWriteEpoch != 0 {
		n += 1 + sovDaemon(uint64(m.LastWriteEpoch))
	}
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *Chunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkSize != 0 {
		n += 1 + sovDaemon(uint64(m.ChunkSize))
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.ShardID)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *WriteStreamRequest_Metadata_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *WriteStreamRequest_Data_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *WriteStreamRequest_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamRequest_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *WriteStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *ReadRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadRequest_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *ReadFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.FileMode != 0 {
		n += 1 + sovDaemon(uint64(m.FileMode))
	}
	if m.SynchronousIO {
		n += 2
	}
	return n
}

func (m *ReadFileRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadFileRequest_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ReadStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	if m.ChunkSize != 0 {
		n += 1 + sovDaemon(uint64(m.ChunkSize))
	}
	return n
}

func (m *ReadStreamRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadStreamRequest_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *ReadStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	return n
}

func (m *DeleteRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *DeleteRequest_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		n += m.Input.Size()
	}
	if m.Fast {
		n += 2
	}
	return n
}

func (m *CheckRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *CheckRequest_Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}
func (m *CheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDaemon(uint64(m.Status))
	}
	return n
}

func (m *RepairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *RepairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *SetMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *SetMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *GetMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DeleteMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListMetadataKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListMetadataKeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataWriteFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataWriteStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataWriteStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataReadFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	if m.FileMode != 0 {
		n += 1 + sovDaemon(uint64(m.FileMode))
	}
	if m.SynchronousIO {
		n += 2
	}
	return n
}

func (m *DataReadFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DataReadStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.ChunkSize != 0 {
		n += 1 + sovDaemon(uint64(m.ChunkSize))
	}
	return n
}

func (m *DataReadStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataChunk)
	if l > 0 {
		n += 1 + l + sovDaemon(uint64(l))
	}
	return n
}

func (m *DataDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DataCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	if m.Fast {
		n += 2
	}
	return n
}

func (m *DataCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDaemon(uint64(m.Status))
	}
	return n
}

func (m *DataRepairRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func (m *DataRepairResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovDaemon(uint64(l))
		}
	}
	return n
}

func sovDaemon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDaemon(x uint64) (n int) {
	return sovDaemon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Metadata) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&Metadata{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`TotalSize:` + fmt.Sprintf("%v", this.TotalSize) + `,`,
		`CreationEpoch:` + fmt.Sprintf("%v", this.CreationEpoch) + `,`,
		`LastWriteEpoch:` + fmt.Sprintf("%v", this.LastWriteEpoch) + `,`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *Chunk) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForObjects := "[]*Object{"
	for _, f := range this.Objects {
		repeatedStringForObjects += strings.Replace(f.String(), "Object", "Object", 1) + ","
	}
	repeatedStringForObjects += "}"
	s := strings.Join([]string{`&Chunk{`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`Objects:` + repeatedStringForObjects + `,`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Object) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Object{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ShardID:` + fmt.Sprintf("%v", this.ShardID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteResponse{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteFileRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteFileResponse{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Metadata_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Metadata_{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "WriteStreamRequest_Metadata", "WriteStreamRequest_Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Data_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Data_{`,
		`Data:` + strings.Replace(fmt.Sprintf("%v", this.Data), "WriteStreamRequest_Data", "WriteStreamRequest_Data", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Metadata{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamRequest_Data) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamRequest_Data{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteStreamResponse{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadResponse{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`FileMode:` + fmt.Sprintf("%v", this.FileMode) + `,`,
		`SynchronousIO:` + fmt.Sprintf("%v", this.SynchronousIO) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadFileResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadStreamResponse{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteResponse{`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest{`,
		`Input:` + fmt.Sprintf("%v", this.Input) + `,`,
		`Fast:` + fmt.Sprintf("%v", this.Fast) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest_Key) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest_Key{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckRequest_Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckRequest_Metadata{`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepairRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepairRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RepairResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RepairResponse{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetMetadataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetMetadataRequest{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetMetadataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetMetadataResponse{`,
		`}`,
	}, "")
	return s
}
func (this *GetMetadataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetMetadataRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetMetadataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetMetadataResponse{`,
		`Metadata:` + strings.Replace(this.Metadata.String(), "Metadata", "Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteMetadataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteMetadataRequest{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteMetadataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteMetadataResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ListMetadataKeysRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetadataKeysRequest{`,
		`}`,
	}, "")
	return s
}
func (this *ListMetadataKeysResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetadataKeysResponse{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteRequest{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataWriteResponse{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteFileRequest{`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataWriteFileResponse{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataWriteStreamRequest{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataWriteStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataWriteStreamResponse{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataReadRequest{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadResponse{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadFileRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataReadFileRequest{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`FileMode:` + fmt.Sprintf("%v", this.FileMode) + `,`,
		`SynchronousIO:` + fmt.Sprintf("%v", this.SynchronousIO) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadFileResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadFileResponse{`,
		`}`,
	}, "")
	return s
}
func (this *DataReadStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataReadStreamRequest{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`ChunkSize:` + fmt.Sprintf("%v", this.ChunkSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataReadStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataReadStreamResponse{`,
		`DataChunk:` + fmt.Sprintf("%v", this.DataChunk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataDeleteRequest{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataDeleteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataDeleteResponse{`,
		`}`,
	}, "")
	return s
}
func (this *DataCheckRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataCheckRequest{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`Fast:` + fmt.Sprintf("%v", this.Fast) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataCheckResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataCheckResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataRepairRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataRepairRequest{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataRepairResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForChunks := "[]*Chunk{"
	for _, f := range this.Chunks {
		repeatedStringForChunks += strings.Replace(f.String(), "Chunk", "Chunk", 1) + ","
	}
	repeatedStringForChunks += "}"
	s := strings.Join([]string{`&DataRepairResponse{`,
		`Chunks:` + repeatedStringForChunks + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDaemon(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpoch", wireType)
			}
			m.CreationEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWriteEpoch", wireType)
			}
			m.LastWriteEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastWriteEpoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteStreamRequest_Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &WriteStreamRequest_Metadata_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteStreamRequest_Data{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &WriteStreamRequest_Data_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest_Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamRequest_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &ReadRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ReadRequest_Metadata{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &ReadFileRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ReadFileRequest_Metadata{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= FileMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousIO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousIO = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &ReadStreamRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &ReadStreamRequest_Metadata{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &DeleteRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &DeleteRequest_Metadata{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Input = &CheckRequest_Key{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &CheckRequest_Metadata{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CheckStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetadataKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetadataKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetadataKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetadataKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetadataKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetadataKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataWriteStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataWriteStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataWriteStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMode", wireType)
			}
			m.FileMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMode |= FileMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SynchronousIO", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SynchronousIO = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReadStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReadStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReadStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataChunk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataChunk = append(m.DataChunk[:0], dAtA[iNdEx:postIndex]...)
			if m.DataChunk == nil {
				m.DataChunk = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CheckStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRepairRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataRepairRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataRepairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataRepairResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataRepairResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataRepairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDaemon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDaemon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDaemon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDaemon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDaemon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDaemon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDaemon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDaemon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDaemon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDaemon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDaemon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDaemon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDaemon = fmt.Errorf("proto: unexpected end of group")
)
